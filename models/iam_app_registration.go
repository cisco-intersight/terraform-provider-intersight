// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IamAppRegistration App Registration
//
// AppRegistration encapsulates the meta-data values of a registered OAuth2 client application, as described in
// https://tools.ietf.org/html/rfc7591#section-2.
// Registered client applications have a set of metadata values associated with their client identifier
// at the Intersight authorization server, including the list of valid redirection URIs or a display name.
// The meta-data is used to specify how a client application can retrieve a OAuth2 Access Token and subsequently
// invoke Intersight API on behalf of this AppRegistration.
//
// To register an OAuth2 application, the following information must be provided.
// 1) Application name
// 2) An icon for the application
// 3) URL to the application's home page
// 4) A short description of the application
// 5) A list of redirect URLs
//
// When an AppRegistration is created, a unique OAuth2 clientId is generated and returned in the HTTP response.
//
// swagger:model iamAppRegistration
type IamAppRegistration struct {
	MoBaseMo

	// A collection of references to the [iam.Account](mo://iam.Account) Managed Object.
	//
	// When this managed object is deleted, the referenced [iam.Account](mo://iam.Account) MO unsets its reference to this deleted MO.
	//
	// Read Only: true
	Account *IamAccountRef `json:"Account,omitempty"`

	// A unique identifier for the OAuth2 client application.
	// The client ID is auto-generated when the AppRegistration object is created.
	//
	//
	// Read Only: true
	ClientID string `json:"ClientId,omitempty"`

	// App Registration name specified by user.
	//
	//
	ClientName string `json:"ClientName,omitempty"`

	// The OAuth2 client secret.
	// The value of this property is generated when grantType includes 'client-credentials'.
	// Otherwise, no client-secret is generated.
	//
	//
	ClientSecret string `json:"ClientSecret,omitempty"`

	// The type of the OAuth2 client (public or confidential), as specified in https://tools.ietf.org/html/rfc6749#section-2.1.
	//
	//
	// Enum: [public confidential]
	ClientType *string `json:"ClientType,omitempty"`

	// Description of the application.
	//
	//
	Description string `json:"Description,omitempty"`

	// The set of grant types that OAuth2 clients can use for this application.
	// The grant type is used in the OAuth2 login flow to validate the grant type that has been requested by the client.
	// See https://tools.ietf.org/html/rfc7591#page-9 for more details.
	//
	// # It is set automatically when AppRegistration is created since currently we do not provide option for the user.
	//
	//
	// Read Only: true
	GrantTypes []*string `json:"GrantTypes"`

	// Collection of the OAuth2 tokens. Each OAuth2 token represents valid OAuth session.
	// OAuth2 token is created when login over OAuth2 is performed using Authorization Code grant type.
	//
	// Read Only: true
	OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

	// Permission associated with OAuth token issued through Client Credentials flow. Permission of the current session will be used.
	//
	// Read Only: true
	Permission *IamPermissionRef `json:"Permission,omitempty"`

	// After a user successfully authorizes an application, the OAuth2 authorization server will redirect the user back to the
	// application with either an authorization code or access token in the URL.
	// Registered redirect URLs may contain query string parameters, but must not contain anything in the fragment.
	// The registration server rejects the request if a user tries to register a redirect URL that contains a fragment.
	// For native and mobile apps, Intersight allows a user to register a URL scheme such as myapp:// which can then be used
	// in the redirect URL. The authorization server allows arbitrary URL schemes to be registered in order to support
	// registering redirect URLs for native apps.
	//
	// Redirect URLs are a critical part of the OAuth flow. After a user successfully authorizes an application,
	// the authorization server will redirect the user back to the application with either an authorization code or access
	// token in the URL. Because the redirect URL will contain sensitive information, it is critical that the service
	// doesnâ€™t redirect the user to arbitrary locations.
	// The best way to ensure the user will only be directed to appropriate locations is to require the developer to
	// register one or more redirect URLs when they create the application.
	//
	// The redirection endpoint URI MUST be an absolute URI.
	//
	//
	RedirectUris []string `json:"RedirectUris"`

	// Set value to true to renew the client-secret. Applicable to client_credentials grant type.
	//
	//
	RenewClientSecret *bool `json:"RenewClientSecret,omitempty"`

	// The set of response types that a OAuth2 client can use.
	// This is static list and it is set automatically when AppRegistration is created.
	// According to RFC, it is used in OAuth2 login flow to check that this AppRegistration supports response type from the request.
	// See https://tools.ietf.org/html/rfc7591#page-9 for more details.
	//
	//
	// Read Only: true
	ResponseTypes []*string `json:"ResponseTypes"`

	// Used to perform revocation for tokens of AppRegistration.
	// Updated only internally is case Revoke property come from UI with value true.
	// On each request with OAuth2 access token the CreationTime of the OAuth2 token will be compared to RevokationTimestamp of the
	// corresponding App Registration.
	//
	//
	// Read Only: true
	// Format: date-time
	RevocationTimestamp strfmt.DateTime `json:"RevocationTimestamp,omitempty"`

	// Used to trigger update the revocationTimestamp value.
	// If UI sent updating request with the Revoke value is true, then update RevocationTimestamp.
	//
	//
	Revoke *bool `json:"Revoke,omitempty"`

	// The set of roles that can be used when a OAuth2 client is accessing this registered application.
	// For example, multiple roles may be defined in your Intersight account, but you want users to login
	// with the 'Read-Only' role when accessing Intersight through a registered application.
	// In that case, the 'roles' property should contain a single element referencing the 'Read-Only' role.
	// A user can only assign roles they already have.
	//
	// This relationship is deprecated. Authorization is now performed by passing the 'scope' query parameter
	// in the first request of the Authorization Code OAuth2 flow.
	// The value of the 'scope' parameter is a list of scope names separated by comma:
	// ROLE.Account Administrator, ROLE.<any role name>.
	//
	Roles []*IamRoleRef `json:"Roles"`

	// A collection of references to the [iam.User](mo://iam.User) Managed Object.
	//
	// When this managed object is deleted, the referenced [iam.User](mo://iam.User) MO unsets its reference to this deleted MO.
	//
	// Read Only: true
	User *IamUserRef `json:"User,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *IamAppRegistration) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		ClientID string `json:"ClientId,omitempty"`

		ClientName string `json:"ClientName,omitempty"`

		ClientSecret string `json:"ClientSecret,omitempty"`

		ClientType *string `json:"ClientType,omitempty"`

		Description string `json:"Description,omitempty"`

		GrantTypes []*string `json:"GrantTypes"`

		OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

		Permission *IamPermissionRef `json:"Permission,omitempty"`

		RedirectUris []string `json:"RedirectUris"`

		RenewClientSecret *bool `json:"RenewClientSecret,omitempty"`

		ResponseTypes []*string `json:"ResponseTypes"`

		RevocationTimestamp strfmt.DateTime `json:"RevocationTimestamp,omitempty"`

		Revoke *bool `json:"Revoke,omitempty"`

		Roles []*IamRoleRef `json:"Roles"`

		User *IamUserRef `json:"User,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Account = dataAO1.Account

	m.ClientID = dataAO1.ClientID

	m.ClientName = dataAO1.ClientName

	m.ClientSecret = dataAO1.ClientSecret

	m.ClientType = dataAO1.ClientType

	m.Description = dataAO1.Description

	m.GrantTypes = dataAO1.GrantTypes

	m.OauthTokens = dataAO1.OauthTokens

	m.Permission = dataAO1.Permission

	m.RedirectUris = dataAO1.RedirectUris

	m.RenewClientSecret = dataAO1.RenewClientSecret

	m.ResponseTypes = dataAO1.ResponseTypes

	m.RevocationTimestamp = dataAO1.RevocationTimestamp

	m.Revoke = dataAO1.Revoke

	m.Roles = dataAO1.Roles

	m.User = dataAO1.User

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m IamAppRegistration) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		ClientID string `json:"ClientId,omitempty"`

		ClientName string `json:"ClientName,omitempty"`

		ClientSecret string `json:"ClientSecret,omitempty"`

		ClientType *string `json:"ClientType,omitempty"`

		Description string `json:"Description,omitempty"`

		GrantTypes []*string `json:"GrantTypes"`

		OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

		Permission *IamPermissionRef `json:"Permission,omitempty"`

		RedirectUris []string `json:"RedirectUris"`

		RenewClientSecret *bool `json:"RenewClientSecret,omitempty"`

		ResponseTypes []*string `json:"ResponseTypes"`

		RevocationTimestamp strfmt.DateTime `json:"RevocationTimestamp,omitempty"`

		Revoke *bool `json:"Revoke,omitempty"`

		Roles []*IamRoleRef `json:"Roles"`

		User *IamUserRef `json:"User,omitempty"`
	}

	dataAO1.Account = m.Account

	dataAO1.ClientID = m.ClientID

	dataAO1.ClientName = m.ClientName

	dataAO1.ClientSecret = m.ClientSecret

	dataAO1.ClientType = m.ClientType

	dataAO1.Description = m.Description

	dataAO1.GrantTypes = m.GrantTypes

	dataAO1.OauthTokens = m.OauthTokens

	dataAO1.Permission = m.Permission

	dataAO1.RedirectUris = m.RedirectUris

	dataAO1.RenewClientSecret = m.RenewClientSecret

	dataAO1.ResponseTypes = m.ResponseTypes

	dataAO1.RevocationTimestamp = m.RevocationTimestamp

	dataAO1.Revoke = m.Revoke

	dataAO1.Roles = m.Roles

	dataAO1.User = m.User

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this iam app registration
func (m *IamAppRegistration) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGrantTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOauthTokens(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermission(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevocationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IamAppRegistration) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Account")
			}
			return err
		}
	}

	return nil
}

var iamAppRegistrationTypeClientTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["public","confidential"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iamAppRegistrationTypeClientTypePropEnum = append(iamAppRegistrationTypeClientTypePropEnum, v)
	}
}

// property enum
func (m *IamAppRegistration) validateClientTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iamAppRegistrationTypeClientTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *IamAppRegistration) validateClientType(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientType) { // not required
		return nil
	}

	// value enum
	if err := m.validateClientTypeEnum("ClientType", "body", *m.ClientType); err != nil {
		return err
	}

	return nil
}

var iamAppRegistrationGrantTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["authorization_code","refresh_token","client_credentials","implicit","password","urn:ietf:params:oauth:grant-type:jwt-bearer","urn:ietf:params:oauth:grant-type:saml2-bearer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iamAppRegistrationGrantTypesItemsEnum = append(iamAppRegistrationGrantTypesItemsEnum, v)
	}
}

func (m *IamAppRegistration) validateGrantTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iamAppRegistrationGrantTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *IamAppRegistration) validateGrantTypes(formats strfmt.Registry) error {

	if swag.IsZero(m.GrantTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.GrantTypes); i++ {
		if swag.IsZero(m.GrantTypes[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateGrantTypesItemsEnum("GrantTypes"+"."+strconv.Itoa(i), "body", *m.GrantTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *IamAppRegistration) validateOauthTokens(formats strfmt.Registry) error {

	if swag.IsZero(m.OauthTokens) { // not required
		return nil
	}

	for i := 0; i < len(m.OauthTokens); i++ {
		if swag.IsZero(m.OauthTokens[i]) { // not required
			continue
		}

		if m.OauthTokens[i] != nil {
			if err := m.OauthTokens[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OauthTokens" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamAppRegistration) validatePermission(formats strfmt.Registry) error {

	if swag.IsZero(m.Permission) { // not required
		return nil
	}

	if m.Permission != nil {
		if err := m.Permission.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Permission")
			}
			return err
		}
	}

	return nil
}

var iamAppRegistrationResponseTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["code","token"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iamAppRegistrationResponseTypesItemsEnum = append(iamAppRegistrationResponseTypesItemsEnum, v)
	}
}

func (m *IamAppRegistration) validateResponseTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iamAppRegistrationResponseTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *IamAppRegistration) validateResponseTypes(formats strfmt.Registry) error {

	if swag.IsZero(m.ResponseTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.ResponseTypes); i++ {
		if swag.IsZero(m.ResponseTypes[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateResponseTypesItemsEnum("ResponseTypes"+"."+strconv.Itoa(i), "body", *m.ResponseTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *IamAppRegistration) validateRevocationTimestamp(formats strfmt.Registry) error {

	if swag.IsZero(m.RevocationTimestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("RevocationTimestamp", "body", "date-time", m.RevocationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *IamAppRegistration) validateRoles(formats strfmt.Registry) error {

	if swag.IsZero(m.Roles) { // not required
		return nil
	}

	for i := 0; i < len(m.Roles); i++ {
		if swag.IsZero(m.Roles[i]) { // not required
			continue
		}

		if m.Roles[i] != nil {
			if err := m.Roles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Roles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamAppRegistration) validateUser(formats strfmt.Registry) error {

	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("User")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IamAppRegistration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IamAppRegistration) UnmarshalBinary(b []byte) error {
	var res IamAppRegistration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
