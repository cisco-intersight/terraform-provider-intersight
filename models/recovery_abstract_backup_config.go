// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecoveryAbstractBackupConfig Backup Policy
//
// Base Backup config which contains all the required inputs to do backup on a local or remote server.
//
// swagger:model recoveryAbstractBackupConfig
type RecoveryAbstractBackupConfig struct {
	PolicyAbstractPolicy

	// The file name for the backup image. This name is added as a prefix in the name for the backup image. A unique file name for the backup image is created along with a timestamp. For example: prefix-1572431305418.
	FileNamePrefix string `json:"FileNamePrefix,omitempty"`

	// is password set
	IsPasswordSet *bool `json:"IsPasswordSet,omitempty"`

	// Specifies whether the backup will be stored locally or remotely.
	// Enum: [Network Share Local Storage]
	LocationType *string `json:"LocationType,omitempty"`

	// Backup server password.
	Password string `json:"Password,omitempty"`

	// The file system path where the backup images must be stored. Include the IP address/hostname of the network share location and the complete file system path. For example: 172.29.109.234/var/backups/
	Path string `json:"Path,omitempty"`

	// Protocol for transferring the backup image to the network share location.
	// Enum: [SCP SFTP FTP]
	Protocol *string `json:"Protocol,omitempty"`

	// Number of backup copies maintained on the local or remote server. When the created backup files exceed this number, the initial backup files are overwritten in a sequential manner.
	RetentionCount int64 `json:"RetentionCount,omitempty"`

	// Backup server user name.
	UserName string `json:"UserName,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *RecoveryAbstractBackupConfig) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 PolicyAbstractPolicy
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.PolicyAbstractPolicy = aO0

	// AO1
	var dataAO1 struct {
		FileNamePrefix string `json:"FileNamePrefix,omitempty"`

		IsPasswordSet *bool `json:"IsPasswordSet,omitempty"`

		LocationType *string `json:"LocationType,omitempty"`

		Password string `json:"Password,omitempty"`

		Path string `json:"Path,omitempty"`

		Protocol *string `json:"Protocol,omitempty"`

		RetentionCount int64 `json:"RetentionCount,omitempty"`

		UserName string `json:"UserName,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.FileNamePrefix = dataAO1.FileNamePrefix

	m.IsPasswordSet = dataAO1.IsPasswordSet

	m.LocationType = dataAO1.LocationType

	m.Password = dataAO1.Password

	m.Path = dataAO1.Path

	m.Protocol = dataAO1.Protocol

	m.RetentionCount = dataAO1.RetentionCount

	m.UserName = dataAO1.UserName

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m RecoveryAbstractBackupConfig) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.PolicyAbstractPolicy)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		FileNamePrefix string `json:"FileNamePrefix,omitempty"`

		IsPasswordSet *bool `json:"IsPasswordSet,omitempty"`

		LocationType *string `json:"LocationType,omitempty"`

		Password string `json:"Password,omitempty"`

		Path string `json:"Path,omitempty"`

		Protocol *string `json:"Protocol,omitempty"`

		RetentionCount int64 `json:"RetentionCount,omitempty"`

		UserName string `json:"UserName,omitempty"`
	}

	dataAO1.FileNamePrefix = m.FileNamePrefix

	dataAO1.IsPasswordSet = m.IsPasswordSet

	dataAO1.LocationType = m.LocationType

	dataAO1.Password = m.Password

	dataAO1.Path = m.Path

	dataAO1.Protocol = m.Protocol

	dataAO1.RetentionCount = m.RetentionCount

	dataAO1.UserName = m.UserName

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this recovery abstract backup config
func (m *RecoveryAbstractBackupConfig) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with PolicyAbstractPolicy
	if err := m.PolicyAbstractPolicy.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recoveryAbstractBackupConfigTypeLocationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Network Share","Local Storage"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recoveryAbstractBackupConfigTypeLocationTypePropEnum = append(recoveryAbstractBackupConfigTypeLocationTypePropEnum, v)
	}
}

// property enum
func (m *RecoveryAbstractBackupConfig) validateLocationTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recoveryAbstractBackupConfigTypeLocationTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecoveryAbstractBackupConfig) validateLocationType(formats strfmt.Registry) error {

	if swag.IsZero(m.LocationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocationTypeEnum("LocationType", "body", *m.LocationType); err != nil {
		return err
	}

	return nil
}

var recoveryAbstractBackupConfigTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SCP","SFTP","FTP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recoveryAbstractBackupConfigTypeProtocolPropEnum = append(recoveryAbstractBackupConfigTypeProtocolPropEnum, v)
	}
}

// property enum
func (m *RecoveryAbstractBackupConfig) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recoveryAbstractBackupConfigTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecoveryAbstractBackupConfig) validateProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("Protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryAbstractBackupConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryAbstractBackupConfig) UnmarshalBinary(b []byte) error {
	var res RecoveryAbstractBackupConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
