// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VirtualizationAbstractVirtualMachine Virtualization:Abstract Virtual Machine
//
// Common attributes of a virtual machine managed by a  hypervisor. Serves as a base class for all concrete virtual machine types. A virtual machine (VM) is what a user and applications interact with. A VM usually runs a guest OS and applications run on the guest OS.
//
// swagger:model virtualizationAbstractVirtualMachine
type VirtualizationAbstractVirtualMachine struct {
	VirtualizationSourceDevice

	// Provisioned CPU and memory information for this virtual machine.
	Capacity *InfraHardwareInfo `json:"Capacity,omitempty"`

	// Guest operating system details running on this machine.
	GuestInfo *VirtualizationGuestInfo `json:"GuestInfo,omitempty"`

	// Type of hypervisor where the virtual machine is hosted, for example VMware ESXi.
	HypervisorType string `json:"HypervisorType,omitempty"`

	// The internally generated identity of this vm. This entity is not manipulated by users. It aids in uniquely identifying the virtual machine object. For VMware, this is MOR (managed object reference).
	Identity string `json:"Identity,omitempty"`

	// The ip address of the virtual machine. There could be multiple addresses of IPv4 and IPv6 types.
	IPAddress []string `json:"IpAddress"`

	// The capacity and usage information for memory on this virtual machine.
	MemoryCapacity *VirtualizationMemoryCapacity `json:"MemoryCapacity,omitempty"`

	// User-provided name to identify the virtual machine.
	Name string `json:"Name,omitempty"`

	// Power state of the virtual machine.
	// Enum: [Unknown PoweredOn PoweredOff StandBy Paused]
	PowerState *string `json:"PowerState,omitempty"`

	// The capacity and usage information for CPU power on this virtual machine.
	ProcessorCapacity *VirtualizationComputeCapacity `json:"ProcessorCapacity,omitempty"`

	// The uuid of this virtual machine. The uuid is internally generated and not user specified.
	UUID string `json:"Uuid,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *VirtualizationAbstractVirtualMachine) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 VirtualizationSourceDevice
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.VirtualizationSourceDevice = aO0

	// AO1
	var dataAO1 struct {
		Capacity *InfraHardwareInfo `json:"Capacity,omitempty"`

		GuestInfo *VirtualizationGuestInfo `json:"GuestInfo,omitempty"`

		HypervisorType string `json:"HypervisorType,omitempty"`

		Identity string `json:"Identity,omitempty"`

		IPAddress []string `json:"IpAddress"`

		MemoryCapacity *VirtualizationMemoryCapacity `json:"MemoryCapacity,omitempty"`

		Name string `json:"Name,omitempty"`

		PowerState *string `json:"PowerState,omitempty"`

		ProcessorCapacity *VirtualizationComputeCapacity `json:"ProcessorCapacity,omitempty"`

		UUID string `json:"Uuid,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Capacity = dataAO1.Capacity

	m.GuestInfo = dataAO1.GuestInfo

	m.HypervisorType = dataAO1.HypervisorType

	m.Identity = dataAO1.Identity

	m.IPAddress = dataAO1.IPAddress

	m.MemoryCapacity = dataAO1.MemoryCapacity

	m.Name = dataAO1.Name

	m.PowerState = dataAO1.PowerState

	m.ProcessorCapacity = dataAO1.ProcessorCapacity

	m.UUID = dataAO1.UUID

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m VirtualizationAbstractVirtualMachine) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.VirtualizationSourceDevice)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		Capacity *InfraHardwareInfo `json:"Capacity,omitempty"`

		GuestInfo *VirtualizationGuestInfo `json:"GuestInfo,omitempty"`

		HypervisorType string `json:"HypervisorType,omitempty"`

		Identity string `json:"Identity,omitempty"`

		IPAddress []string `json:"IpAddress"`

		MemoryCapacity *VirtualizationMemoryCapacity `json:"MemoryCapacity,omitempty"`

		Name string `json:"Name,omitempty"`

		PowerState *string `json:"PowerState,omitempty"`

		ProcessorCapacity *VirtualizationComputeCapacity `json:"ProcessorCapacity,omitempty"`

		UUID string `json:"Uuid,omitempty"`
	}

	dataAO1.Capacity = m.Capacity

	dataAO1.GuestInfo = m.GuestInfo

	dataAO1.HypervisorType = m.HypervisorType

	dataAO1.Identity = m.Identity

	dataAO1.IPAddress = m.IPAddress

	dataAO1.MemoryCapacity = m.MemoryCapacity

	dataAO1.Name = m.Name

	dataAO1.PowerState = m.PowerState

	dataAO1.ProcessorCapacity = m.ProcessorCapacity

	dataAO1.UUID = m.UUID

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this virtualization abstract virtual machine
func (m *VirtualizationAbstractVirtualMachine) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with VirtualizationSourceDevice
	if err := m.VirtualizationSourceDevice.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGuestInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoryCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePowerState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessorCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VirtualizationAbstractVirtualMachine) validateCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.Capacity) { // not required
		return nil
	}

	if m.Capacity != nil {
		if err := m.Capacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Capacity")
			}
			return err
		}
	}

	return nil
}

func (m *VirtualizationAbstractVirtualMachine) validateGuestInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.GuestInfo) { // not required
		return nil
	}

	if m.GuestInfo != nil {
		if err := m.GuestInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GuestInfo")
			}
			return err
		}
	}

	return nil
}

func (m *VirtualizationAbstractVirtualMachine) validateMemoryCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.MemoryCapacity) { // not required
		return nil
	}

	if m.MemoryCapacity != nil {
		if err := m.MemoryCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("MemoryCapacity")
			}
			return err
		}
	}

	return nil
}

var virtualizationAbstractVirtualMachineTypePowerStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","PoweredOn","PoweredOff","StandBy","Paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		virtualizationAbstractVirtualMachineTypePowerStatePropEnum = append(virtualizationAbstractVirtualMachineTypePowerStatePropEnum, v)
	}
}

// property enum
func (m *VirtualizationAbstractVirtualMachine) validatePowerStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, virtualizationAbstractVirtualMachineTypePowerStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VirtualizationAbstractVirtualMachine) validatePowerState(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerState) { // not required
		return nil
	}

	// value enum
	if err := m.validatePowerStateEnum("PowerState", "body", *m.PowerState); err != nil {
		return err
	}

	return nil
}

func (m *VirtualizationAbstractVirtualMachine) validateProcessorCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessorCapacity) { // not required
		return nil
	}

	if m.ProcessorCapacity != nil {
		if err := m.ProcessorCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ProcessorCapacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VirtualizationAbstractVirtualMachine) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VirtualizationAbstractVirtualMachine) UnmarshalBinary(b []byte) error {
	var res VirtualizationAbstractVirtualMachine
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
