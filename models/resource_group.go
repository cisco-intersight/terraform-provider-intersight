// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ResourceGroup Resource:Group
//
// A group of REST resources, such as a group of compute.Blade MOs. A ResourceGroup can contain static members which are specified as a set of object references, or it can contain dynamic members, which are specified through OData query filters. A Resource can be part of multiple resource groups.
//
// swagger:model resourceGroup
type ResourceGroup struct {
	MoBaseMo

	// The account to which this resource group belongs to.
	// Read Only: true
	Account *IamAccountRef `json:"Account,omitempty"`

	// The name of this resource group.
	Name string `json:"Name,omitempty"`

	// A collection of references to the [organization.Organization](mo://organization.Organization) Managed Object.
	// When this managed object is deleted, the referenced [organization.Organization](mo://organization.Organization) MOs unset their reference to this deleted MO.
	Organizations []*OrganizationOrganizationRef `json:"Organizations"`

	// A single filter expression created by OR'ing the $filter criteria of the 'selectors' of a given object type. Used to efficiently maintain the membership of the group. This filter is maintained per object type in this type.
	// Read Only: true
	PerTypeCombinedSelector []*ResourcePerTypeCombinedSelector `json:"PerTypeCombinedSelector"`

	// Qualifier shall be used to specify if we want to organize resources using multiple resource group or single For an account, resource groups can be of only one of the above types. (Both the types are mutually exclusive for an account.).
	// Enum: [Allow-Selectors Allow-All]
	Qualifier *string `json:"Qualifier,omitempty"`

	// A list of ODATA filters to select resources. The group selectors may be include URLs of individual resources, or OData query with filters that match multiple queries. The URLs must be relative (i.e. do not include the host).
	Selectors []*ResourceSelector `json:"Selectors"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ResourceGroup) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		Name string `json:"Name,omitempty"`

		Organizations []*OrganizationOrganizationRef `json:"Organizations"`

		PerTypeCombinedSelector []*ResourcePerTypeCombinedSelector `json:"PerTypeCombinedSelector"`

		Qualifier *string `json:"Qualifier,omitempty"`

		Selectors []*ResourceSelector `json:"Selectors"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Account = dataAO1.Account

	m.Name = dataAO1.Name

	m.Organizations = dataAO1.Organizations

	m.PerTypeCombinedSelector = dataAO1.PerTypeCombinedSelector

	m.Qualifier = dataAO1.Qualifier

	m.Selectors = dataAO1.Selectors

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ResourceGroup) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		Name string `json:"Name,omitempty"`

		Organizations []*OrganizationOrganizationRef `json:"Organizations"`

		PerTypeCombinedSelector []*ResourcePerTypeCombinedSelector `json:"PerTypeCombinedSelector"`

		Qualifier *string `json:"Qualifier,omitempty"`

		Selectors []*ResourceSelector `json:"Selectors"`
	}

	dataAO1.Account = m.Account

	dataAO1.Name = m.Name

	dataAO1.Organizations = m.Organizations

	dataAO1.PerTypeCombinedSelector = m.PerTypeCombinedSelector

	dataAO1.Qualifier = m.Qualifier

	dataAO1.Selectors = m.Selectors

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this resource group
func (m *ResourceGroup) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganizations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerTypeCombinedSelector(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQualifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelectors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResourceGroup) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Account")
			}
			return err
		}
	}

	return nil
}

func (m *ResourceGroup) validateOrganizations(formats strfmt.Registry) error {

	if swag.IsZero(m.Organizations) { // not required
		return nil
	}

	for i := 0; i < len(m.Organizations); i++ {
		if swag.IsZero(m.Organizations[i]) { // not required
			continue
		}

		if m.Organizations[i] != nil {
			if err := m.Organizations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Organizations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResourceGroup) validatePerTypeCombinedSelector(formats strfmt.Registry) error {

	if swag.IsZero(m.PerTypeCombinedSelector) { // not required
		return nil
	}

	for i := 0; i < len(m.PerTypeCombinedSelector); i++ {
		if swag.IsZero(m.PerTypeCombinedSelector[i]) { // not required
			continue
		}

		if m.PerTypeCombinedSelector[i] != nil {
			if err := m.PerTypeCombinedSelector[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("PerTypeCombinedSelector" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var resourceGroupTypeQualifierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow-Selectors","Allow-All"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		resourceGroupTypeQualifierPropEnum = append(resourceGroupTypeQualifierPropEnum, v)
	}
}

// property enum
func (m *ResourceGroup) validateQualifierEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, resourceGroupTypeQualifierPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ResourceGroup) validateQualifier(formats strfmt.Registry) error {

	if swag.IsZero(m.Qualifier) { // not required
		return nil
	}

	// value enum
	if err := m.validateQualifierEnum("Qualifier", "body", *m.Qualifier); err != nil {
		return err
	}

	return nil
}

func (m *ResourceGroup) validateSelectors(formats strfmt.Registry) error {

	if swag.IsZero(m.Selectors) { // not required
		return nil
	}

	for i := 0; i < len(m.Selectors); i++ {
		if swag.IsZero(m.Selectors[i]) { // not required
			continue
		}

		if m.Selectors[i] != nil {
			if err := m.Selectors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Selectors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResourceGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResourceGroup) UnmarshalBinary(b []byte) error {
	var res ResourceGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
