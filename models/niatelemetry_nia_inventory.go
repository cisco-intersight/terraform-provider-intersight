// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// NiatelemetryNiaInventory Niatelemetry:Nia Inventory
//
// Inventory object available per device scope. This common object holds a device level information.
//
// swagger:model niatelemetryNiaInventory
type NiatelemetryNiaInventory struct {
	MoBaseMo

	// CPU usage of device being inventoried. This determines the percentage of CPU resources used.
	CPU float32 `json:"Cpu,omitempty"`

	// Last crash reset reason of device being inventoried. This determines the last reason for a device's restart due to crash of the system.
	CrashResetLogs string `json:"CrashResetLogs,omitempty"`

	// Name of device being inventoried. The name the user assigns to the device is inventoried here.
	DeviceName string `json:"DeviceName,omitempty"`

	// Type of device being inventoried. This determines whether the device is a controller, leaf or spine.
	DeviceType string `json:"DeviceType,omitempty"`

	// Disk Usage of device being inventoried. This determines the amount of disk usage.
	Disk *NiatelemetryDiskinfo `json:"Disk,omitempty"`

	// The license of this device. It includes features and license information.
	LicenseState *NiatelemetryNiaLicenseStateRef `json:"LicenseState,omitempty"`

	// Last log in time device being inventoried. This determines the last login time on the device.
	LogInTime string `json:"LogInTime,omitempty"`

	// Last log out time of device being inventoried. This determines the last logout time on the device.
	LogOutTime string `json:"LogOutTime,omitempty"`

	// Memory usage of device being inventoried. This determines the percentage of memory resources used.
	Memory int64 `json:"Memory,omitempty"`

	// Type of record DCNM / APIC / SE. This determines the type of platform where inventory was collected.
	RecordType string `json:"RecordType,omitempty"`

	// Version of record being pushed. This determines what was the API version for data available from the device.
	RecordVersion string `json:"RecordVersion,omitempty"`

	// Relationship to the Device Registration object for this setup.
	// Read Only: true
	RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

	// Serial number of device being invetoried. The serial number is unique per device and will be used as the key.
	Serial string `json:"Serial,omitempty"`

	// Last software downloaded of device being inventoried. This determines if software download API was used.
	SoftwareDownload string `json:"SoftwareDownload,omitempty"`

	// Software version of device being inventoried. The various software version values for each device are available on cisco.com.
	Version string `json:"Version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *NiatelemetryNiaInventory) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		CPU float32 `json:"Cpu,omitempty"`

		CrashResetLogs string `json:"CrashResetLogs,omitempty"`

		DeviceName string `json:"DeviceName,omitempty"`

		DeviceType string `json:"DeviceType,omitempty"`

		Disk *NiatelemetryDiskinfo `json:"Disk,omitempty"`

		LicenseState *NiatelemetryNiaLicenseStateRef `json:"LicenseState,omitempty"`

		LogInTime string `json:"LogInTime,omitempty"`

		LogOutTime string `json:"LogOutTime,omitempty"`

		Memory int64 `json:"Memory,omitempty"`

		RecordType string `json:"RecordType,omitempty"`

		RecordVersion string `json:"RecordVersion,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		Serial string `json:"Serial,omitempty"`

		SoftwareDownload string `json:"SoftwareDownload,omitempty"`

		Version string `json:"Version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.CPU = dataAO1.CPU

	m.CrashResetLogs = dataAO1.CrashResetLogs

	m.DeviceName = dataAO1.DeviceName

	m.DeviceType = dataAO1.DeviceType

	m.Disk = dataAO1.Disk

	m.LicenseState = dataAO1.LicenseState

	m.LogInTime = dataAO1.LogInTime

	m.LogOutTime = dataAO1.LogOutTime

	m.Memory = dataAO1.Memory

	m.RecordType = dataAO1.RecordType

	m.RecordVersion = dataAO1.RecordVersion

	m.RegisteredDevice = dataAO1.RegisteredDevice

	m.Serial = dataAO1.Serial

	m.SoftwareDownload = dataAO1.SoftwareDownload

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m NiatelemetryNiaInventory) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		CPU float32 `json:"Cpu,omitempty"`

		CrashResetLogs string `json:"CrashResetLogs,omitempty"`

		DeviceName string `json:"DeviceName,omitempty"`

		DeviceType string `json:"DeviceType,omitempty"`

		Disk *NiatelemetryDiskinfo `json:"Disk,omitempty"`

		LicenseState *NiatelemetryNiaLicenseStateRef `json:"LicenseState,omitempty"`

		LogInTime string `json:"LogInTime,omitempty"`

		LogOutTime string `json:"LogOutTime,omitempty"`

		Memory int64 `json:"Memory,omitempty"`

		RecordType string `json:"RecordType,omitempty"`

		RecordVersion string `json:"RecordVersion,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		Serial string `json:"Serial,omitempty"`

		SoftwareDownload string `json:"SoftwareDownload,omitempty"`

		Version string `json:"Version,omitempty"`
	}

	dataAO1.CPU = m.CPU

	dataAO1.CrashResetLogs = m.CrashResetLogs

	dataAO1.DeviceName = m.DeviceName

	dataAO1.DeviceType = m.DeviceType

	dataAO1.Disk = m.Disk

	dataAO1.LicenseState = m.LicenseState

	dataAO1.LogInTime = m.LogInTime

	dataAO1.LogOutTime = m.LogOutTime

	dataAO1.Memory = m.Memory

	dataAO1.RecordType = m.RecordType

	dataAO1.RecordVersion = m.RecordVersion

	dataAO1.RegisteredDevice = m.RegisteredDevice

	dataAO1.Serial = m.Serial

	dataAO1.SoftwareDownload = m.SoftwareDownload

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this niatelemetry nia inventory
func (m *NiatelemetryNiaInventory) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NiatelemetryNiaInventory) validateDisk(formats strfmt.Registry) error {

	if swag.IsZero(m.Disk) { // not required
		return nil
	}

	if m.Disk != nil {
		if err := m.Disk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Disk")
			}
			return err
		}
	}

	return nil
}

func (m *NiatelemetryNiaInventory) validateLicenseState(formats strfmt.Registry) error {

	if swag.IsZero(m.LicenseState) { // not required
		return nil
	}

	if m.LicenseState != nil {
		if err := m.LicenseState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LicenseState")
			}
			return err
		}
	}

	return nil
}

func (m *NiatelemetryNiaInventory) validateRegisteredDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.RegisteredDevice) { // not required
		return nil
	}

	if m.RegisteredDevice != nil {
		if err := m.RegisteredDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RegisteredDevice")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NiatelemetryNiaInventory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NiatelemetryNiaInventory) UnmarshalBinary(b []byte) error {
	var res NiatelemetryNiaInventory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
