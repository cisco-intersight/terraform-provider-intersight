// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetConnectionControlMessage Asset:Connection Control Message
//
// Control message used to update the context of a devices connection. When a device registration is modified (e.g. by a user modifying the claim status) the process managing the connection must be notified of the change. On changes aurora will attempt to send the change to the current owner of the connection.
//
// swagger:model assetConnectionControlMessage
type AssetConnectionControlMessage struct {
	MoBaseComplexType

	AssetConnectionControlMessageAO1P1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *AssetConnectionControlMessage) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseComplexType
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseComplexType = aO0

	// AO1
	var aO1 AssetConnectionControlMessageAO1P1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.AssetConnectionControlMessageAO1P1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m AssetConnectionControlMessage) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseComplexType)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	aO1, err := swag.WriteJSON(m.AssetConnectionControlMessageAO1P1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this asset connection control message
func (m *AssetConnectionControlMessage) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseComplexType
	if err := m.MoBaseComplexType.Validate(formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with AssetConnectionControlMessageAO1P1
	if err := m.AssetConnectionControlMessageAO1P1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AssetConnectionControlMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetConnectionControlMessage) UnmarshalBinary(b []byte) error {
	var res AssetConnectionControlMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AssetConnectionControlMessageAO1P1 asset connection control message a o1 p1
//
// swagger:model AssetConnectionControlMessageAO1P1
type AssetConnectionControlMessageAO1P1 struct {

	// The account id to which the device belongs.
	Account string `json:"Account,omitempty"`

	// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
	ConnectorVersion string `json:"ConnectorVersion,omitempty"`

	// The Moid of the device under change. Used to route the message to a devices connection.
	DeviceID string `json:"DeviceId,omitempty"`

	// The domain group id to which the device belongs.
	DomainGroup string `json:"DomainGroup,omitempty"`

	// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
	Evict *bool `json:"Evict,omitempty"`

	// The current leadership of a device cluster member.
	// Enum: [Unknown Primary Secondary]
	Leadership *string `json:"Leadership,omitempty"`

	// The new identity assigned to a device on ownership change (claim/unclaim).
	NewIdentity string `json:"NewIdentity,omitempty"`

	// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
	Partition int64 `json:"Partition,omitempty"`

	// asset connection control message a o1 p1
	AssetConnectionControlMessageAO1P1 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *AssetConnectionControlMessageAO1P1) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The account id to which the device belongs.
		Account string `json:"Account,omitempty"`

		// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
		ConnectorVersion string `json:"ConnectorVersion,omitempty"`

		// The Moid of the device under change. Used to route the message to a devices connection.
		DeviceID string `json:"DeviceId,omitempty"`

		// The domain group id to which the device belongs.
		DomainGroup string `json:"DomainGroup,omitempty"`

		// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
		Evict *bool `json:"Evict,omitempty"`

		// The current leadership of a device cluster member.
		// Enum: [Unknown Primary Secondary]
		Leadership *string `json:"Leadership,omitempty"`

		// The new identity assigned to a device on ownership change (claim/unclaim).
		NewIdentity string `json:"NewIdentity,omitempty"`

		// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
		Partition int64 `json:"Partition,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv AssetConnectionControlMessageAO1P1

	rcv.Account = stage1.Account
	rcv.ConnectorVersion = stage1.ConnectorVersion
	rcv.DeviceID = stage1.DeviceID
	rcv.DomainGroup = stage1.DomainGroup
	rcv.Evict = stage1.Evict
	rcv.Leadership = stage1.Leadership
	rcv.NewIdentity = stage1.NewIdentity
	rcv.Partition = stage1.Partition
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "Account")
	delete(stage2, "ConnectorVersion")
	delete(stage2, "DeviceId")
	delete(stage2, "DomainGroup")
	delete(stage2, "Evict")
	delete(stage2, "Leadership")
	delete(stage2, "NewIdentity")
	delete(stage2, "Partition")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.AssetConnectionControlMessageAO1P1 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m AssetConnectionControlMessageAO1P1) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The account id to which the device belongs.
		Account string `json:"Account,omitempty"`

		// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
		ConnectorVersion string `json:"ConnectorVersion,omitempty"`

		// The Moid of the device under change. Used to route the message to a devices connection.
		DeviceID string `json:"DeviceId,omitempty"`

		// The domain group id to which the device belongs.
		DomainGroup string `json:"DomainGroup,omitempty"`

		// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
		Evict *bool `json:"Evict,omitempty"`

		// The current leadership of a device cluster member.
		// Enum: [Unknown Primary Secondary]
		Leadership *string `json:"Leadership,omitempty"`

		// The new identity assigned to a device on ownership change (claim/unclaim).
		NewIdentity string `json:"NewIdentity,omitempty"`

		// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
		Partition int64 `json:"Partition,omitempty"`
	}

	stage1.Account = m.Account
	stage1.ConnectorVersion = m.ConnectorVersion
	stage1.DeviceID = m.DeviceID
	stage1.DomainGroup = m.DomainGroup
	stage1.Evict = m.Evict
	stage1.Leadership = m.Leadership
	stage1.NewIdentity = m.NewIdentity
	stage1.Partition = m.Partition

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.AssetConnectionControlMessageAO1P1) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.AssetConnectionControlMessageAO1P1)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this asset connection control message a o1 p1
func (m *AssetConnectionControlMessageAO1P1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLeadership(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var assetConnectionControlMessageAO1P1TypeLeadershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","Primary","Secondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetConnectionControlMessageAO1P1TypeLeadershipPropEnum = append(assetConnectionControlMessageAO1P1TypeLeadershipPropEnum, v)
	}
}

const (

	// AssetConnectionControlMessageAO1P1LeadershipUnknown captures enum value "Unknown"
	AssetConnectionControlMessageAO1P1LeadershipUnknown string = "Unknown"

	// AssetConnectionControlMessageAO1P1LeadershipPrimary captures enum value "Primary"
	AssetConnectionControlMessageAO1P1LeadershipPrimary string = "Primary"

	// AssetConnectionControlMessageAO1P1LeadershipSecondary captures enum value "Secondary"
	AssetConnectionControlMessageAO1P1LeadershipSecondary string = "Secondary"
)

// prop value enum
func (m *AssetConnectionControlMessageAO1P1) validateLeadershipEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetConnectionControlMessageAO1P1TypeLeadershipPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetConnectionControlMessageAO1P1) validateLeadership(formats strfmt.Registry) error {

	if swag.IsZero(m.Leadership) { // not required
		return nil
	}

	// value enum
	if err := m.validateLeadershipEnum("Leadership", "body", *m.Leadership); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetConnectionControlMessageAO1P1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetConnectionControlMessageAO1P1) UnmarshalBinary(b []byte) error {
	var res AssetConnectionControlMessageAO1P1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
