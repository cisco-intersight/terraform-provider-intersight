// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IamOAuthToken OAuth2 Token
//
// The meta data for generating OAuth2 token of a user.
// It is created when user logged in via OAuth2 using Authorization Code grant
// and deleted upon logout, expiration timeout or manual deletion.
//
// swagger:model iamOAuthToken
type IamOAuthToken struct {
	MoBaseMo

	// Expiration time for the JWT token to which it can be used for api calls.
	// Read Only: true
	// Format: date-time
	AccessExpirationTime strfmt.DateTime `json:"AccessExpirationTime,omitempty"`

	// A collection of references to the [iam.AppRegistration](mo://iam.AppRegistration) Managed Object.
	// When this managed object is deleted, the referenced [iam.AppRegistration](mo://iam.AppRegistration) MO unsets its reference to this deleted MO.
	// Read Only: true
	AppRegistration *IamAppRegistrationRef `json:"AppRegistration,omitempty"`

	// The identifier of the registered application to which the token belongs.
	ClientID string `json:"ClientId,omitempty"`

	// The user agent IP address from which the auth token is launched.
	// Read Only: true
	ClientIPAddress string `json:"ClientIpAddress,omitempty"`

	// The name of the registered application to which the token belongs.
	ClientName string `json:"ClientName,omitempty"`

	// Expiration time for the JWT token to which it can be refreshed.
	// Read Only: true
	// Format: date-time
	ExpirationTime strfmt.DateTime `json:"ExpirationTime,omitempty"`

	// The client address from which last login is initiated.
	// Read Only: true
	LastLoginClient string `json:"LastLoginClient,omitempty"`

	// The last login time for user.
	// Read Only: true
	// Format: date-time
	LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

	// Permissions associated with the OAuth session.
	// Permissions provides a way to assign roles to a user or user group to perform operations on object hierarchy.
	// Read Only: true
	Permission *IamPermissionRef `json:"Permission,omitempty"`

	// Token identifier. Not the Access Token itself.
	// Read Only: true
	TokenID string `json:"TokenId,omitempty"`

	// A collection of references to the [iam.User](mo://iam.User) Managed Object.
	// When this managed object is deleted, the referenced [iam.User](mo://iam.User) MO unsets its reference to this deleted MO.
	// Read Only: true
	User *IamUserRef `json:"User,omitempty"`

	// User Device meta information.
	UserMeta *IamClientMeta `json:"UserMeta,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *IamOAuthToken) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		AccessExpirationTime strfmt.DateTime `json:"AccessExpirationTime,omitempty"`

		AppRegistration *IamAppRegistrationRef `json:"AppRegistration,omitempty"`

		ClientID string `json:"ClientId,omitempty"`

		ClientIPAddress string `json:"ClientIpAddress,omitempty"`

		ClientName string `json:"ClientName,omitempty"`

		ExpirationTime strfmt.DateTime `json:"ExpirationTime,omitempty"`

		LastLoginClient string `json:"LastLoginClient,omitempty"`

		LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

		Permission *IamPermissionRef `json:"Permission,omitempty"`

		TokenID string `json:"TokenId,omitempty"`

		User *IamUserRef `json:"User,omitempty"`

		UserMeta *IamClientMeta `json:"UserMeta,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AccessExpirationTime = dataAO1.AccessExpirationTime

	m.AppRegistration = dataAO1.AppRegistration

	m.ClientID = dataAO1.ClientID

	m.ClientIPAddress = dataAO1.ClientIPAddress

	m.ClientName = dataAO1.ClientName

	m.ExpirationTime = dataAO1.ExpirationTime

	m.LastLoginClient = dataAO1.LastLoginClient

	m.LastLoginTime = dataAO1.LastLoginTime

	m.Permission = dataAO1.Permission

	m.TokenID = dataAO1.TokenID

	m.User = dataAO1.User

	m.UserMeta = dataAO1.UserMeta

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m IamOAuthToken) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		AccessExpirationTime strfmt.DateTime `json:"AccessExpirationTime,omitempty"`

		AppRegistration *IamAppRegistrationRef `json:"AppRegistration,omitempty"`

		ClientID string `json:"ClientId,omitempty"`

		ClientIPAddress string `json:"ClientIpAddress,omitempty"`

		ClientName string `json:"ClientName,omitempty"`

		ExpirationTime strfmt.DateTime `json:"ExpirationTime,omitempty"`

		LastLoginClient string `json:"LastLoginClient,omitempty"`

		LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

		Permission *IamPermissionRef `json:"Permission,omitempty"`

		TokenID string `json:"TokenId,omitempty"`

		User *IamUserRef `json:"User,omitempty"`

		UserMeta *IamClientMeta `json:"UserMeta,omitempty"`
	}

	dataAO1.AccessExpirationTime = m.AccessExpirationTime

	dataAO1.AppRegistration = m.AppRegistration

	dataAO1.ClientID = m.ClientID

	dataAO1.ClientIPAddress = m.ClientIPAddress

	dataAO1.ClientName = m.ClientName

	dataAO1.ExpirationTime = m.ExpirationTime

	dataAO1.LastLoginClient = m.LastLoginClient

	dataAO1.LastLoginTime = m.LastLoginTime

	dataAO1.Permission = m.Permission

	dataAO1.TokenID = m.TokenID

	dataAO1.User = m.User

	dataAO1.UserMeta = m.UserMeta

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this iam o auth token
func (m *IamOAuthToken) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessExpirationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppRegistration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastLoginTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermission(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserMeta(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IamOAuthToken) validateAccessExpirationTime(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessExpirationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("AccessExpirationTime", "body", "date-time", m.AccessExpirationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *IamOAuthToken) validateAppRegistration(formats strfmt.Registry) error {

	if swag.IsZero(m.AppRegistration) { // not required
		return nil
	}

	if m.AppRegistration != nil {
		if err := m.AppRegistration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AppRegistration")
			}
			return err
		}
	}

	return nil
}

func (m *IamOAuthToken) validateExpirationTime(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpirationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("ExpirationTime", "body", "date-time", m.ExpirationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *IamOAuthToken) validateLastLoginTime(formats strfmt.Registry) error {

	if swag.IsZero(m.LastLoginTime) { // not required
		return nil
	}

	if err := validate.FormatOf("LastLoginTime", "body", "date-time", m.LastLoginTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *IamOAuthToken) validatePermission(formats strfmt.Registry) error {

	if swag.IsZero(m.Permission) { // not required
		return nil
	}

	if m.Permission != nil {
		if err := m.Permission.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Permission")
			}
			return err
		}
	}

	return nil
}

func (m *IamOAuthToken) validateUser(formats strfmt.Registry) error {

	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("User")
			}
			return err
		}
	}

	return nil
}

func (m *IamOAuthToken) validateUserMeta(formats strfmt.Registry) error {

	if swag.IsZero(m.UserMeta) { // not required
		return nil
	}

	if m.UserMeta != nil {
		if err := m.UserMeta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("UserMeta")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IamOAuthToken) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IamOAuthToken) UnmarshalBinary(b []byte) error {
	var res IamOAuthToken
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
