// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConnectorScopedInventory Connector:Scoped Inventory
//
// Abstract object defined to handle scoped inventory for a set of objects identified by the query parameters defined in the properties. All vendor specific scoped inventory objects will inherit from this object and the scoped inventory framework will address the inventory  collection.
//
// swagger:model connectorScopedInventory
type ConnectorScopedInventory struct {
	MoBaseMo

	// A property that uniquely identifies the object to be inventoried as a part of the scoped inventory.
	NamingProperty string `json:"NamingProperty,omitempty"`

	// Type of the object for which scoped inventory needs to be run.
	Type string `json:"Type,omitempty"`

	// Set of values of the namingProperty. namingProperty and values will be used to evaluate the objects to be inventoried. For example: In order to inventory a volume. Type: storage.Volume NamingProperty: Name Values: [testVolume1].
	Values []string `json:"Values"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ConnectorScopedInventory) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		NamingProperty string `json:"NamingProperty,omitempty"`

		Type string `json:"Type,omitempty"`

		Values []string `json:"Values"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.NamingProperty = dataAO1.NamingProperty

	m.Type = dataAO1.Type

	m.Values = dataAO1.Values

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ConnectorScopedInventory) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		NamingProperty string `json:"NamingProperty,omitempty"`

		Type string `json:"Type,omitempty"`

		Values []string `json:"Values"`
	}

	dataAO1.NamingProperty = m.NamingProperty

	dataAO1.Type = m.Type

	dataAO1.Values = m.Values

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this connector scoped inventory
func (m *ConnectorScopedInventory) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorScopedInventory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorScopedInventory) UnmarshalBinary(b []byte) error {
	var res ConnectorScopedInventory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
