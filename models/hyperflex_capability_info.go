// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// HyperflexCapabilityInfo Hyperflex Capabilities and Feature limits Information
//
// A capabilityInfo is like a feature set and/or feature limit for different components of a HyperFlex Cluster. A set of constraints defines the rules, and the corresponding value either determines if the feature would work on a HyperFlex cluster with specific component set, or corresponds to a limit for a set of HyperFlex components. For example, "minUcsVersion" for HyperFlex version "4.0.1a" corresponds to "3.2.3" or "minHxdpVersion" for HyperFlex Upgrade operation is "4.0.1a" etc. This data can be captured as a capability and at run-time, decision can be made to proceed with the intended operation or not, or proceed with the intended operation with a value catered to specific feature sets.
//
// swagger:model hyperflexCapabilityInfo
type HyperflexCapabilityInfo struct {
	MoBaseMo

	// A collection of references to the [hyperflex.AppCatalog](mo://hyperflex.AppCatalog) Managed Object.
	//
	// When this managed object is deleted, the referenced [hyperflex.AppCatalog](mo://hyperflex.AppCatalog) MO unsets its reference to this deleted MO.
	//
	AppCatalog *HyperflexAppCatalogRef `json:"AppCatalog,omitempty"`

	// Collection of constraints, which when applied together in tandem with an "AND" assertion, will correspond to the specified Value. Hence the Value will make sense only iff all the constraints match.
	//
	CapabilityConstraints []*HclConstraint `json:"CapabilityConstraints"`

	// Name of the capability or feature set consisting of a collection of constraint rules and value.
	//
	Name string `json:"Name,omitempty"`

	// Capability Value which is valid only iff all specified constraints match.
	//
	// Read Only: true
	Value string `json:"Value,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *HyperflexCapabilityInfo) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		AppCatalog *HyperflexAppCatalogRef `json:"AppCatalog,omitempty"`

		CapabilityConstraints []*HclConstraint `json:"CapabilityConstraints"`

		Name string `json:"Name,omitempty"`

		Value string `json:"Value,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AppCatalog = dataAO1.AppCatalog

	m.CapabilityConstraints = dataAO1.CapabilityConstraints

	m.Name = dataAO1.Name

	m.Value = dataAO1.Value

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m HyperflexCapabilityInfo) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		AppCatalog *HyperflexAppCatalogRef `json:"AppCatalog,omitempty"`

		CapabilityConstraints []*HclConstraint `json:"CapabilityConstraints"`

		Name string `json:"Name,omitempty"`

		Value string `json:"Value,omitempty"`
	}

	dataAO1.AppCatalog = m.AppCatalog

	dataAO1.CapabilityConstraints = m.CapabilityConstraints

	dataAO1.Name = m.Name

	dataAO1.Value = m.Value

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this hyperflex capability info
func (m *HyperflexCapabilityInfo) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppCatalog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapabilityConstraints(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HyperflexCapabilityInfo) validateAppCatalog(formats strfmt.Registry) error {

	if swag.IsZero(m.AppCatalog) { // not required
		return nil
	}

	if m.AppCatalog != nil {
		if err := m.AppCatalog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AppCatalog")
			}
			return err
		}
	}

	return nil
}

func (m *HyperflexCapabilityInfo) validateCapabilityConstraints(formats strfmt.Registry) error {

	if swag.IsZero(m.CapabilityConstraints) { // not required
		return nil
	}

	for i := 0; i < len(m.CapabilityConstraints); i++ {
		if swag.IsZero(m.CapabilityConstraints[i]) { // not required
			continue
		}

		if m.CapabilityConstraints[i] != nil {
			if err := m.CapabilityConstraints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CapabilityConstraints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HyperflexCapabilityInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HyperflexCapabilityInfo) UnmarshalBinary(b []byte) error {
	var res HyperflexCapabilityInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
