// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IamUser Iam:User
//
// The Intersight account user.
//
// swagger:model iamUser
type IamUser struct {
	MoBaseMo

	// Current user's API keys. API keys are used to programatically perform API calls.
	// Read Only: true
	APIKeys []*IamAPIKeyRef `json:"ApiKeys"`

	// List of registered OAuth2 applications created by the User.
	// Read Only: true
	AppRegistrations []*IamAppRegistrationRef `json:"AppRegistrations"`

	// IP address from which the user last logged in to Intersight.
	// Read Only: true
	ClientIPAddress string `json:"ClientIpAddress,omitempty"`

	// Email of the user. Users are added to Intersight using the email configured in the IdP.
	Email string `json:"Email,omitempty"`

	// First name of the user. This field is populated from the IdP attributes received after authentication.
	// Read Only: true
	FirstName string `json:"FirstName,omitempty"`

	// A collection of references to the [iam.Idp](mo://iam.Idp) Managed Object.
	// When this managed object is deleted, the referenced [iam.Idp](mo://iam.Idp) MO unsets its reference to this deleted MO.
	Idp *IamIdpRef `json:"Idp,omitempty"`

	// A collection of references to the [iam.IdpReference](mo://iam.IdpReference) Managed Object.
	// When this managed object is deleted, the referenced [iam.IdpReference](mo://iam.IdpReference) MO unsets its reference to this deleted MO.
	Idpreference *IamIdpReferenceRef `json:"Idpreference,omitempty"`

	// Last successful login time for user.
	// Read Only: true
	// Format: date-time
	LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

	// Last name of the user. This field is populated from the IdP attributes received after authentication.
	// Read Only: true
	LastName string `json:"LastName,omitempty"`

	// A collection of references to the [iam.LocalUserPassword](mo://iam.LocalUserPassword) Managed Object.
	// When this managed object is deleted, the referenced [iam.LocalUserPassword](mo://iam.LocalUserPassword) MO unsets its reference to this deleted MO.
	// Read Only: true
	LocalUserPassword *IamLocalUserPasswordRef `json:"LocalUserPassword,omitempty"`

	// Name as configured in the IdP.
	// Read Only: true
	Name string `json:"Name,omitempty"`

	// Collection of the available OAuthTokens.
	// Each OAuthToken lives 30 days unless it is deleted manually by User.
	// OAuthToken is created when Login performed via OAuth Client (AppRegistration).
	// OAuthToken itself is not sensitive data since it doesn't contain salt, salt is stored in Vault.
	// Read Only: true
	OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

	// Permissions assigned to the user. Permission provides a way to assign roles to a user or user group to perform operations on object hierarchy.
	Permissions []*IamPermissionRef `json:"Permissions"`

	// Current user's web sessions. After a user logs into Intersight, a session object is created. This session object is deleted upon logout, idle timeout, expiry timeout, or manual deletion.
	// Read Only: true
	Sessions []*IamSessionRef `json:"Sessions"`

	// UserID or email as configured in the IdP.
	UserIDOrEmail string `json:"UserIdOrEmail,omitempty"`

	// Type of the User. If a user is added manually by specifying the email address, or has logged in using groups, based on the IdP attributes received during authentication. If added manually, the user type will be static, otherwise dynamic.
	// Read Only: true
	UserType string `json:"UserType,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *IamUser) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		APIKeys []*IamAPIKeyRef `json:"ApiKeys"`

		AppRegistrations []*IamAppRegistrationRef `json:"AppRegistrations"`

		ClientIPAddress string `json:"ClientIpAddress,omitempty"`

		Email string `json:"Email,omitempty"`

		FirstName string `json:"FirstName,omitempty"`

		Idp *IamIdpRef `json:"Idp,omitempty"`

		Idpreference *IamIdpReferenceRef `json:"Idpreference,omitempty"`

		LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

		LastName string `json:"LastName,omitempty"`

		LocalUserPassword *IamLocalUserPasswordRef `json:"LocalUserPassword,omitempty"`

		Name string `json:"Name,omitempty"`

		OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

		Permissions []*IamPermissionRef `json:"Permissions"`

		Sessions []*IamSessionRef `json:"Sessions"`

		UserIDOrEmail string `json:"UserIdOrEmail,omitempty"`

		UserType string `json:"UserType,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.APIKeys = dataAO1.APIKeys

	m.AppRegistrations = dataAO1.AppRegistrations

	m.ClientIPAddress = dataAO1.ClientIPAddress

	m.Email = dataAO1.Email

	m.FirstName = dataAO1.FirstName

	m.Idp = dataAO1.Idp

	m.Idpreference = dataAO1.Idpreference

	m.LastLoginTime = dataAO1.LastLoginTime

	m.LastName = dataAO1.LastName

	m.LocalUserPassword = dataAO1.LocalUserPassword

	m.Name = dataAO1.Name

	m.OauthTokens = dataAO1.OauthTokens

	m.Permissions = dataAO1.Permissions

	m.Sessions = dataAO1.Sessions

	m.UserIDOrEmail = dataAO1.UserIDOrEmail

	m.UserType = dataAO1.UserType

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m IamUser) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		APIKeys []*IamAPIKeyRef `json:"ApiKeys"`

		AppRegistrations []*IamAppRegistrationRef `json:"AppRegistrations"`

		ClientIPAddress string `json:"ClientIpAddress,omitempty"`

		Email string `json:"Email,omitempty"`

		FirstName string `json:"FirstName,omitempty"`

		Idp *IamIdpRef `json:"Idp,omitempty"`

		Idpreference *IamIdpReferenceRef `json:"Idpreference,omitempty"`

		LastLoginTime strfmt.DateTime `json:"LastLoginTime,omitempty"`

		LastName string `json:"LastName,omitempty"`

		LocalUserPassword *IamLocalUserPasswordRef `json:"LocalUserPassword,omitempty"`

		Name string `json:"Name,omitempty"`

		OauthTokens []*IamOAuthTokenRef `json:"OauthTokens"`

		Permissions []*IamPermissionRef `json:"Permissions"`

		Sessions []*IamSessionRef `json:"Sessions"`

		UserIDOrEmail string `json:"UserIdOrEmail,omitempty"`

		UserType string `json:"UserType,omitempty"`
	}

	dataAO1.APIKeys = m.APIKeys

	dataAO1.AppRegistrations = m.AppRegistrations

	dataAO1.ClientIPAddress = m.ClientIPAddress

	dataAO1.Email = m.Email

	dataAO1.FirstName = m.FirstName

	dataAO1.Idp = m.Idp

	dataAO1.Idpreference = m.Idpreference

	dataAO1.LastLoginTime = m.LastLoginTime

	dataAO1.LastName = m.LastName

	dataAO1.LocalUserPassword = m.LocalUserPassword

	dataAO1.Name = m.Name

	dataAO1.OauthTokens = m.OauthTokens

	dataAO1.Permissions = m.Permissions

	dataAO1.Sessions = m.Sessions

	dataAO1.UserIDOrEmail = m.UserIDOrEmail

	dataAO1.UserType = m.UserType

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this iam user
func (m *IamUser) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAPIKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppRegistrations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdpreference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastLoginTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalUserPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOauthTokens(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IamUser) validateAPIKeys(formats strfmt.Registry) error {

	if swag.IsZero(m.APIKeys) { // not required
		return nil
	}

	for i := 0; i < len(m.APIKeys); i++ {
		if swag.IsZero(m.APIKeys[i]) { // not required
			continue
		}

		if m.APIKeys[i] != nil {
			if err := m.APIKeys[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ApiKeys" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamUser) validateAppRegistrations(formats strfmt.Registry) error {

	if swag.IsZero(m.AppRegistrations) { // not required
		return nil
	}

	for i := 0; i < len(m.AppRegistrations); i++ {
		if swag.IsZero(m.AppRegistrations[i]) { // not required
			continue
		}

		if m.AppRegistrations[i] != nil {
			if err := m.AppRegistrations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AppRegistrations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamUser) validateIdp(formats strfmt.Registry) error {

	if swag.IsZero(m.Idp) { // not required
		return nil
	}

	if m.Idp != nil {
		if err := m.Idp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Idp")
			}
			return err
		}
	}

	return nil
}

func (m *IamUser) validateIdpreference(formats strfmt.Registry) error {

	if swag.IsZero(m.Idpreference) { // not required
		return nil
	}

	if m.Idpreference != nil {
		if err := m.Idpreference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Idpreference")
			}
			return err
		}
	}

	return nil
}

func (m *IamUser) validateLastLoginTime(formats strfmt.Registry) error {

	if swag.IsZero(m.LastLoginTime) { // not required
		return nil
	}

	if err := validate.FormatOf("LastLoginTime", "body", "date-time", m.LastLoginTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *IamUser) validateLocalUserPassword(formats strfmt.Registry) error {

	if swag.IsZero(m.LocalUserPassword) { // not required
		return nil
	}

	if m.LocalUserPassword != nil {
		if err := m.LocalUserPassword.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LocalUserPassword")
			}
			return err
		}
	}

	return nil
}

func (m *IamUser) validateOauthTokens(formats strfmt.Registry) error {

	if swag.IsZero(m.OauthTokens) { // not required
		return nil
	}

	for i := 0; i < len(m.OauthTokens); i++ {
		if swag.IsZero(m.OauthTokens[i]) { // not required
			continue
		}

		if m.OauthTokens[i] != nil {
			if err := m.OauthTokens[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OauthTokens" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamUser) validatePermissions(formats strfmt.Registry) error {

	if swag.IsZero(m.Permissions) { // not required
		return nil
	}

	for i := 0; i < len(m.Permissions); i++ {
		if swag.IsZero(m.Permissions[i]) { // not required
			continue
		}

		if m.Permissions[i] != nil {
			if err := m.Permissions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Permissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IamUser) validateSessions(formats strfmt.Registry) error {

	if swag.IsZero(m.Sessions) { // not required
		return nil
	}

	for i := 0; i < len(m.Sessions); i++ {
		if swag.IsZero(m.Sessions[i]) { // not required
			continue
		}

		if m.Sessions[i] != nil {
			if err := m.Sessions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Sessions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *IamUser) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IamUser) UnmarshalBinary(b []byte) error {
	var res IamUser
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
