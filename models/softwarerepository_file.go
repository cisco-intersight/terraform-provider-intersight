// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SoftwarerepositoryFile Softwarerepository:File
//
// A file that resides either in an external repository or has been imported to the local repository. If the file is available in the local repository, it is marked as cached. If not, it represents a pointer to a file in an external repository. Instances of this MO will be implicitly created as part of the file import operation.
//
// swagger:model softwarerepositoryFile
type SoftwarerepositoryFile struct {
	MoBaseMo

	// User provided description about the file. Cisco provided description for image inventoried from a Cisco repository.
	Description string `json:"Description,omitempty"`

	// The number of times this file has been downloaded from the local repository. It is used by the repository monitoring process to determine the files that are to be evicted from the cache.
	// Read Only: true
	DownloadCount int64 `json:"DownloadCount,omitempty"`

	// The action to be performed on the imported file. If 'PreCache' is set, the image will be cached in Appliance. Applicable in Intersight appliance deployment. If 'Evict' is set, the cached file will be removed. Applicable in Intersight appliance deployment. If 'GeneratePreSignedUploadUrl' is set, generates pre signed URL (s) for the file to be imported into the repository. Applicable for local machine source. The URL (s) will be populated under LocalMachine file server. If 'CompleteImportProcess' is set, the ImportState is marked as 'Imported'. Applicable for local machine source. If 'Cancel' is set, the ImportState is marked as 'Failed'. Applicable for local machine source.
	// Enum: [None GeneratePreSignedUploadUrl GeneratePreSignedDownloadUrl CompleteImportProcess PreCache Cancel Evict]
	ImportAction *string `json:"ImportAction,omitempty"`

	// The state  of this file in the repository or Appliance. The importState is updated during the import operation and as part of the repository monitoring process.
	// Read Only: true
	// Enum: [ReadyForImport Importing Imported Failed MetaOnly ReadyForCache Caching Cached CachingFailed Corrupted Evicted]
	ImportState string `json:"ImportState,omitempty"`

	// The time at which this image or file was imported/cached into the repositry. if the 'ImportState' is 'Imported', the time at which this image or file was imported. if the 'ImportState' is 'Cached', the time at which this image or file was cached.
	// Read Only: true
	// Format: date-time
	ImportedTime strfmt.DateTime `json:"ImportedTime,omitempty"`

	// The time at which this file was last downloaded from the local repository. It is used by the repository monitoring process to determine the files that are to be evicted from the cache.
	// Read Only: true
	// Format: date-time
	LastAccessTime strfmt.DateTime `json:"LastAccessTime,omitempty"`

	// The md5sum checksum of the file. This information is available for all Cisco distributed images and files imported to the local repository.
	Md5sum string `json:"Md5sum,omitempty"`

	// The name of the file. It is populated as part of the image import operation.
	Name string `json:"Name,omitempty"`

	// The date on which the file was released or distributed by its vendor.
	// Format: date-time
	ReleaseDate strfmt.DateTime `json:"ReleaseDate,omitempty"`

	// The sha512sum of the file. This information is available for all Cisco distributed images and files imported to the local repository.
	Sha512sum string `json:"Sha512sum,omitempty"`

	// The size (in bytes) of the file. This information is available for all Cisco distributed images and files imported to the local repository.
	Size int64 `json:"Size,omitempty"`

	// The software advisory, if any, provided by the vendor for this file.
	SoftwareAdvisoryURL string `json:"SoftwareAdvisoryUrl,omitempty"`

	// Location of the file in an external repository.
	Source *SoftwarerepositoryFileServer `json:"Source,omitempty"`

	// Vendor provided version for the file.
	Version string `json:"Version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *SoftwarerepositoryFile) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Description string `json:"Description,omitempty"`

		DownloadCount int64 `json:"DownloadCount,omitempty"`

		ImportAction *string `json:"ImportAction,omitempty"`

		ImportState string `json:"ImportState,omitempty"`

		ImportedTime strfmt.DateTime `json:"ImportedTime,omitempty"`

		LastAccessTime strfmt.DateTime `json:"LastAccessTime,omitempty"`

		Md5sum string `json:"Md5sum,omitempty"`

		Name string `json:"Name,omitempty"`

		ReleaseDate strfmt.DateTime `json:"ReleaseDate,omitempty"`

		Sha512sum string `json:"Sha512sum,omitempty"`

		Size int64 `json:"Size,omitempty"`

		SoftwareAdvisoryURL string `json:"SoftwareAdvisoryUrl,omitempty"`

		Source *SoftwarerepositoryFileServer `json:"Source,omitempty"`

		Version string `json:"Version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Description = dataAO1.Description

	m.DownloadCount = dataAO1.DownloadCount

	m.ImportAction = dataAO1.ImportAction

	m.ImportState = dataAO1.ImportState

	m.ImportedTime = dataAO1.ImportedTime

	m.LastAccessTime = dataAO1.LastAccessTime

	m.Md5sum = dataAO1.Md5sum

	m.Name = dataAO1.Name

	m.ReleaseDate = dataAO1.ReleaseDate

	m.Sha512sum = dataAO1.Sha512sum

	m.Size = dataAO1.Size

	m.SoftwareAdvisoryURL = dataAO1.SoftwareAdvisoryURL

	m.Source = dataAO1.Source

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m SoftwarerepositoryFile) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		Description string `json:"Description,omitempty"`

		DownloadCount int64 `json:"DownloadCount,omitempty"`

		ImportAction *string `json:"ImportAction,omitempty"`

		ImportState string `json:"ImportState,omitempty"`

		ImportedTime strfmt.DateTime `json:"ImportedTime,omitempty"`

		LastAccessTime strfmt.DateTime `json:"LastAccessTime,omitempty"`

		Md5sum string `json:"Md5sum,omitempty"`

		Name string `json:"Name,omitempty"`

		ReleaseDate strfmt.DateTime `json:"ReleaseDate,omitempty"`

		Sha512sum string `json:"Sha512sum,omitempty"`

		Size int64 `json:"Size,omitempty"`

		SoftwareAdvisoryURL string `json:"SoftwareAdvisoryUrl,omitempty"`

		Source *SoftwarerepositoryFileServer `json:"Source,omitempty"`

		Version string `json:"Version,omitempty"`
	}

	dataAO1.Description = m.Description

	dataAO1.DownloadCount = m.DownloadCount

	dataAO1.ImportAction = m.ImportAction

	dataAO1.ImportState = m.ImportState

	dataAO1.ImportedTime = m.ImportedTime

	dataAO1.LastAccessTime = m.LastAccessTime

	dataAO1.Md5sum = m.Md5sum

	dataAO1.Name = m.Name

	dataAO1.ReleaseDate = m.ReleaseDate

	dataAO1.Sha512sum = m.Sha512sum

	dataAO1.Size = m.Size

	dataAO1.SoftwareAdvisoryURL = m.SoftwareAdvisoryURL

	dataAO1.Source = m.Source

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this softwarerepository file
func (m *SoftwarerepositoryFile) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastAccessTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var softwarerepositoryFileTypeImportActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","GeneratePreSignedUploadUrl","GeneratePreSignedDownloadUrl","CompleteImportProcess","PreCache","Cancel","Evict"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		softwarerepositoryFileTypeImportActionPropEnum = append(softwarerepositoryFileTypeImportActionPropEnum, v)
	}
}

// property enum
func (m *SoftwarerepositoryFile) validateImportActionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, softwarerepositoryFileTypeImportActionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SoftwarerepositoryFile) validateImportAction(formats strfmt.Registry) error {

	if swag.IsZero(m.ImportAction) { // not required
		return nil
	}

	// value enum
	if err := m.validateImportActionEnum("ImportAction", "body", *m.ImportAction); err != nil {
		return err
	}

	return nil
}

var softwarerepositoryFileTypeImportStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ReadyForImport","Importing","Imported","Failed","MetaOnly","ReadyForCache","Caching","Cached","CachingFailed","Corrupted","Evicted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		softwarerepositoryFileTypeImportStatePropEnum = append(softwarerepositoryFileTypeImportStatePropEnum, v)
	}
}

// property enum
func (m *SoftwarerepositoryFile) validateImportStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, softwarerepositoryFileTypeImportStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SoftwarerepositoryFile) validateImportState(formats strfmt.Registry) error {

	if swag.IsZero(m.ImportState) { // not required
		return nil
	}

	// value enum
	if err := m.validateImportStateEnum("ImportState", "body", m.ImportState); err != nil {
		return err
	}

	return nil
}

func (m *SoftwarerepositoryFile) validateImportedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.ImportedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("ImportedTime", "body", "date-time", m.ImportedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SoftwarerepositoryFile) validateLastAccessTime(formats strfmt.Registry) error {

	if swag.IsZero(m.LastAccessTime) { // not required
		return nil
	}

	if err := validate.FormatOf("LastAccessTime", "body", "date-time", m.LastAccessTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SoftwarerepositoryFile) validateReleaseDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ReleaseDate) { // not required
		return nil
	}

	if err := validate.FormatOf("ReleaseDate", "body", "date-time", m.ReleaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SoftwarerepositoryFile) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SoftwarerepositoryFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwarerepositoryFile) UnmarshalBinary(b []byte) error {
	var res SoftwarerepositoryFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
