// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MemoryPersistentMemoryPolicy Persistent Memory
//
// The Persistent Memory policy defines the reusable Persistent Memory related configuration that can be applied on many servers. This policy allows the application of Persistent Memory Goals and creation of Persistent Memory Regions and Namespaces. The encryption of the Persistent Memory Modules can be enabled through this policy by providing a passphrase.
//
// swagger:model memoryPersistentMemoryPolicy
type MemoryPersistentMemoryPolicy struct {
	PolicyAbstractPolicy

	// The list of Persistent Memory Goals that need to be created through this policy.
	Goals []*MemoryPersistentMemoryGoal `json:"Goals"`

	// Local security for the Persistent Memory Modules on the server.
	LocalSecurity *MemoryPersistentMemoryLocalSecurity `json:"LocalSecurity,omitempty"`

	// The list of Persistent Memory Namespace spec that need to be created through this policy.
	LogicalNamespaces []*MemoryPersistentMemoryLogicalNamespace `json:"LogicalNamespaces"`

	// Management Mode of the policy. This can be either Configured from Intersight or Configured from Operating System.
	// Enum: [configured-from-intersight configured-from-operating-system]
	ManagementMode *string `json:"ManagementMode,omitempty"`

	// Relationship to the Organization that owns the Managed Object.
	Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

	// Relationship to the profile objects.
	Profiles []*PolicyAbstractConfigProfileRef `json:"Profiles"`

	// Persistent Memory Namespaces to be retained or not.
	RetainNamespaces *bool `json:"RetainNamespaces,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *MemoryPersistentMemoryPolicy) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 PolicyAbstractPolicy
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.PolicyAbstractPolicy = aO0

	// AO1
	var dataAO1 struct {
		Goals []*MemoryPersistentMemoryGoal `json:"Goals"`

		LocalSecurity *MemoryPersistentMemoryLocalSecurity `json:"LocalSecurity,omitempty"`

		LogicalNamespaces []*MemoryPersistentMemoryLogicalNamespace `json:"LogicalNamespaces"`

		ManagementMode *string `json:"ManagementMode,omitempty"`

		Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

		Profiles []*PolicyAbstractConfigProfileRef `json:"Profiles"`

		RetainNamespaces *bool `json:"RetainNamespaces,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Goals = dataAO1.Goals

	m.LocalSecurity = dataAO1.LocalSecurity

	m.LogicalNamespaces = dataAO1.LogicalNamespaces

	m.ManagementMode = dataAO1.ManagementMode

	m.Organization = dataAO1.Organization

	m.Profiles = dataAO1.Profiles

	m.RetainNamespaces = dataAO1.RetainNamespaces

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m MemoryPersistentMemoryPolicy) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.PolicyAbstractPolicy)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		Goals []*MemoryPersistentMemoryGoal `json:"Goals"`

		LocalSecurity *MemoryPersistentMemoryLocalSecurity `json:"LocalSecurity,omitempty"`

		LogicalNamespaces []*MemoryPersistentMemoryLogicalNamespace `json:"LogicalNamespaces"`

		ManagementMode *string `json:"ManagementMode,omitempty"`

		Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

		Profiles []*PolicyAbstractConfigProfileRef `json:"Profiles"`

		RetainNamespaces *bool `json:"RetainNamespaces,omitempty"`
	}

	dataAO1.Goals = m.Goals

	dataAO1.LocalSecurity = m.LocalSecurity

	dataAO1.LogicalNamespaces = m.LogicalNamespaces

	dataAO1.ManagementMode = m.ManagementMode

	dataAO1.Organization = m.Organization

	dataAO1.Profiles = m.Profiles

	dataAO1.RetainNamespaces = m.RetainNamespaces

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this memory persistent memory policy
func (m *MemoryPersistentMemoryPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with PolicyAbstractPolicy
	if err := m.PolicyAbstractPolicy.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGoals(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogicalNamespaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfiles(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateGoals(formats strfmt.Registry) error {

	if swag.IsZero(m.Goals) { // not required
		return nil
	}

	for i := 0; i < len(m.Goals); i++ {
		if swag.IsZero(m.Goals[i]) { // not required
			continue
		}

		if m.Goals[i] != nil {
			if err := m.Goals[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Goals" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateLocalSecurity(formats strfmt.Registry) error {

	if swag.IsZero(m.LocalSecurity) { // not required
		return nil
	}

	if m.LocalSecurity != nil {
		if err := m.LocalSecurity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LocalSecurity")
			}
			return err
		}
	}

	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateLogicalNamespaces(formats strfmt.Registry) error {

	if swag.IsZero(m.LogicalNamespaces) { // not required
		return nil
	}

	for i := 0; i < len(m.LogicalNamespaces); i++ {
		if swag.IsZero(m.LogicalNamespaces[i]) { // not required
			continue
		}

		if m.LogicalNamespaces[i] != nil {
			if err := m.LogicalNamespaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("LogicalNamespaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var memoryPersistentMemoryPolicyTypeManagementModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configured-from-intersight","configured-from-operating-system"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		memoryPersistentMemoryPolicyTypeManagementModePropEnum = append(memoryPersistentMemoryPolicyTypeManagementModePropEnum, v)
	}
}

// property enum
func (m *MemoryPersistentMemoryPolicy) validateManagementModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, memoryPersistentMemoryPolicyTypeManagementModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateManagementMode(formats strfmt.Registry) error {

	if swag.IsZero(m.ManagementMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateManagementModeEnum("ManagementMode", "body", *m.ManagementMode); err != nil {
		return err
	}

	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateOrganization(formats strfmt.Registry) error {

	if swag.IsZero(m.Organization) { // not required
		return nil
	}

	if m.Organization != nil {
		if err := m.Organization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Organization")
			}
			return err
		}
	}

	return nil
}

func (m *MemoryPersistentMemoryPolicy) validateProfiles(formats strfmt.Registry) error {

	if swag.IsZero(m.Profiles) { // not required
		return nil
	}

	for i := 0; i < len(m.Profiles); i++ {
		if swag.IsZero(m.Profiles[i]) { // not required
			continue
		}

		if m.Profiles[i] != nil {
			if err := m.Profiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MemoryPersistentMemoryPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MemoryPersistentMemoryPolicy) UnmarshalBinary(b []byte) error {
	var res MemoryPersistentMemoryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
