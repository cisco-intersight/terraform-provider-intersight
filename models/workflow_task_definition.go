// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// WorkflowTaskDefinition Workflow:Task Definition
//
// Used to define a task which can be included within a workflow. Task definition conveys the intent that we want to achieve with the task. We can have a standalone task definition that is bound to a single implementation for that task, or we can define an TaskDefinition that will serve as the interface task definition which is linked to multiple implementation tasks. Each implemented TaskDefinition will be bound to its own implementation so we can achieve a case where single TaskDefinition has multiple implementations.
//
// swagger:model workflowTaskDefinition
type WorkflowTaskDefinition struct {
	MoBaseMo

	// The catalog under which the definition has been added.
	//
	Catalog *WorkflowCatalogRef `json:"Catalog,omitempty"`

	// When true this will be the task version that is used when a specific task definition version is not specified. The very first task definition created with a name will be set as the default version, after that user can explicitly set any version of the task definition as the default version.
	//
	DefaultVersion *bool `json:"DefaultVersion,omitempty"`

	// The task definition description to describe what this task will do when executed.
	//
	Description string `json:"Description,omitempty"`

	// List of all the implemented task for this TaskDefinition. When this list is populated it implies that this TaskDefinition has multiple implementations.
	//
	ImplementedTasks []*WorkflowTaskDefinitionRef `json:"ImplementedTasks"`

	// A collection of references to the [workflow.TaskDefinition](mo://workflow.TaskDefinition) Managed Object.
	//
	// When this managed object is deleted, the referenced [workflow.TaskDefinition](mo://workflow.TaskDefinition) MO unsets its reference to this deleted MO.
	//
	InterfaceTask *WorkflowTaskDefinitionRef `json:"InterfaceTask,omitempty"`

	// Type to capture all the internal properties for the task definition.
	//
	// Read Only: true
	InternalProperties *WorkflowInternalProperties `json:"InternalProperties,omitempty"`

	// A user friendly short name to identify the task definition.
	//
	Label string `json:"Label,omitempty"`

	// The name of the task definition. The name should follow this convention <Verb or Action><Category><Vendor><Product><Noun or object> Verb or Action is a required portion of the name and this must be part of the pre-approved verb list. Category is an optional field and this will refer to the broad category of the task referring to the type of resource or endpoint. If there is no specific category then use "Generic" if required. Vendor is an optional field and this will refer to the specific vendor this task applies to. If the task is generic and not tied to a vendor, then do not specify anything. Product is an optional field, this will contain the vendor product and model when desired. Noun or object is a required field and  this will contain the noun or object on which the action is being performed. Examples SendEmail  - This is a task in Generic category for sending email. NewStorageVolume - This is a vendor agnostic task under Storage device category for creating a new volume.
	//
	Name string `json:"Name,omitempty"`

	// Type to capture all the properties for the task definition.
	//
	Properties *WorkflowProperties `json:"Properties,omitempty"`

	// The version of the task definition so we can support multiple versions of a task definition.
	//
	Version int64 `json:"Version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *WorkflowTaskDefinition) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Catalog *WorkflowCatalogRef `json:"Catalog,omitempty"`

		DefaultVersion *bool `json:"DefaultVersion,omitempty"`

		Description string `json:"Description,omitempty"`

		ImplementedTasks []*WorkflowTaskDefinitionRef `json:"ImplementedTasks"`

		InterfaceTask *WorkflowTaskDefinitionRef `json:"InterfaceTask,omitempty"`

		InternalProperties *WorkflowInternalProperties `json:"InternalProperties,omitempty"`

		Label string `json:"Label,omitempty"`

		Name string `json:"Name,omitempty"`

		Properties *WorkflowProperties `json:"Properties,omitempty"`

		Version int64 `json:"Version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Catalog = dataAO1.Catalog

	m.DefaultVersion = dataAO1.DefaultVersion

	m.Description = dataAO1.Description

	m.ImplementedTasks = dataAO1.ImplementedTasks

	m.InterfaceTask = dataAO1.InterfaceTask

	m.InternalProperties = dataAO1.InternalProperties

	m.Label = dataAO1.Label

	m.Name = dataAO1.Name

	m.Properties = dataAO1.Properties

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m WorkflowTaskDefinition) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		Catalog *WorkflowCatalogRef `json:"Catalog,omitempty"`

		DefaultVersion *bool `json:"DefaultVersion,omitempty"`

		Description string `json:"Description,omitempty"`

		ImplementedTasks []*WorkflowTaskDefinitionRef `json:"ImplementedTasks"`

		InterfaceTask *WorkflowTaskDefinitionRef `json:"InterfaceTask,omitempty"`

		InternalProperties *WorkflowInternalProperties `json:"InternalProperties,omitempty"`

		Label string `json:"Label,omitempty"`

		Name string `json:"Name,omitempty"`

		Properties *WorkflowProperties `json:"Properties,omitempty"`

		Version int64 `json:"Version,omitempty"`
	}

	dataAO1.Catalog = m.Catalog

	dataAO1.DefaultVersion = m.DefaultVersion

	dataAO1.Description = m.Description

	dataAO1.ImplementedTasks = m.ImplementedTasks

	dataAO1.InterfaceTask = m.InterfaceTask

	dataAO1.InternalProperties = m.InternalProperties

	dataAO1.Label = m.Label

	dataAO1.Name = m.Name

	dataAO1.Properties = m.Properties

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this workflow task definition
func (m *WorkflowTaskDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImplementedTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterfaceTask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInternalProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProperties(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *WorkflowTaskDefinition) validateCatalog(formats strfmt.Registry) error {

	if swag.IsZero(m.Catalog) { // not required
		return nil
	}

	if m.Catalog != nil {
		if err := m.Catalog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Catalog")
			}
			return err
		}
	}

	return nil
}

func (m *WorkflowTaskDefinition) validateImplementedTasks(formats strfmt.Registry) error {

	if swag.IsZero(m.ImplementedTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.ImplementedTasks); i++ {
		if swag.IsZero(m.ImplementedTasks[i]) { // not required
			continue
		}

		if m.ImplementedTasks[i] != nil {
			if err := m.ImplementedTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ImplementedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *WorkflowTaskDefinition) validateInterfaceTask(formats strfmt.Registry) error {

	if swag.IsZero(m.InterfaceTask) { // not required
		return nil
	}

	if m.InterfaceTask != nil {
		if err := m.InterfaceTask.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("InterfaceTask")
			}
			return err
		}
	}

	return nil
}

func (m *WorkflowTaskDefinition) validateInternalProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.InternalProperties) { // not required
		return nil
	}

	if m.InternalProperties != nil {
		if err := m.InternalProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("InternalProperties")
			}
			return err
		}
	}

	return nil
}

func (m *WorkflowTaskDefinition) validateProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.Properties) { // not required
		return nil
	}

	if m.Properties != nil {
		if err := m.Properties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Properties")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *WorkflowTaskDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *WorkflowTaskDefinition) UnmarshalBinary(b []byte) error {
	var res WorkflowTaskDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
