// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ForecastInstance Forecast:Instance
//
// Entity representing forecast result for instance of managed object, ie, data source.
//
// swagger:model forecastInstance
type ForecastInstance struct {
	MoBaseMo

	// Experimental predictive model generated from the historical data using experimental algorithm. The two models are used to plot and do a comparision.
	// Read Only: true
	AltModel []float64 `json:"AltModel"`

	// The Moid of the Intersight managed device instance for which regression model is derived.
	// Read Only: true
	DeviceID string `json:"DeviceId,omitempty"`

	// The relationship to the forecast definition based on which the instance is generated.
	// Read Only: true
	ForecastDef *ForecastDefinitionRef `json:"ForecastDef,omitempty"`

	// The number of days remaining before the device reaches its full functional capacity.
	// Read Only: true
	FullCapDays int64 `json:"FullCapDays,omitempty"`

	// The name of the metric for which regression model is generated.
	// Read Only: true
	MetricName string `json:"MetricName,omitempty"`

	// The minimum number of days the HyperFlex cluster should be up for computing forecast.
	// Read Only: true
	MinDaysForForecast int64 `json:"MinDaysForForecast,omitempty"`

	// Predictive model generated from the historical data of a device or source.
	// Read Only: true
	Model *ForecastModel `json:"Model,omitempty"`

	// The relationship to the registered device for which forecast is computed.
	// Read Only: true
	RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

	// The number of days remaining before the device reaches the specified threshold for the metric as defined in definition.
	// Read Only: true
	ThresholdDays int64 `json:"ThresholdDays,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ForecastInstance) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		AltModel []float64 `json:"AltModel"`

		DeviceID string `json:"DeviceId,omitempty"`

		ForecastDef *ForecastDefinitionRef `json:"ForecastDef,omitempty"`

		FullCapDays int64 `json:"FullCapDays,omitempty"`

		MetricName string `json:"MetricName,omitempty"`

		MinDaysForForecast int64 `json:"MinDaysForForecast,omitempty"`

		Model *ForecastModel `json:"Model,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		ThresholdDays int64 `json:"ThresholdDays,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AltModel = dataAO1.AltModel

	m.DeviceID = dataAO1.DeviceID

	m.ForecastDef = dataAO1.ForecastDef

	m.FullCapDays = dataAO1.FullCapDays

	m.MetricName = dataAO1.MetricName

	m.MinDaysForForecast = dataAO1.MinDaysForForecast

	m.Model = dataAO1.Model

	m.RegisteredDevice = dataAO1.RegisteredDevice

	m.ThresholdDays = dataAO1.ThresholdDays

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ForecastInstance) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		AltModel []float64 `json:"AltModel"`

		DeviceID string `json:"DeviceId,omitempty"`

		ForecastDef *ForecastDefinitionRef `json:"ForecastDef,omitempty"`

		FullCapDays int64 `json:"FullCapDays,omitempty"`

		MetricName string `json:"MetricName,omitempty"`

		MinDaysForForecast int64 `json:"MinDaysForForecast,omitempty"`

		Model *ForecastModel `json:"Model,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		ThresholdDays int64 `json:"ThresholdDays,omitempty"`
	}

	dataAO1.AltModel = m.AltModel

	dataAO1.DeviceID = m.DeviceID

	dataAO1.ForecastDef = m.ForecastDef

	dataAO1.FullCapDays = m.FullCapDays

	dataAO1.MetricName = m.MetricName

	dataAO1.MinDaysForForecast = m.MinDaysForForecast

	dataAO1.Model = m.Model

	dataAO1.RegisteredDevice = m.RegisteredDevice

	dataAO1.ThresholdDays = m.ThresholdDays

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this forecast instance
func (m *ForecastInstance) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForecastDef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ForecastInstance) validateForecastDef(formats strfmt.Registry) error {

	if swag.IsZero(m.ForecastDef) { // not required
		return nil
	}

	if m.ForecastDef != nil {
		if err := m.ForecastDef.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ForecastDef")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastInstance) validateModel(formats strfmt.Registry) error {

	if swag.IsZero(m.Model) { // not required
		return nil
	}

	if m.Model != nil {
		if err := m.Model.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Model")
			}
			return err
		}
	}

	return nil
}

func (m *ForecastInstance) validateRegisteredDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.RegisteredDevice) { // not required
		return nil
	}

	if m.RegisteredDevice != nil {
		if err := m.RegisteredDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RegisteredDevice")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastInstance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastInstance) UnmarshalBinary(b []byte) error {
	var res ForecastInstance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
