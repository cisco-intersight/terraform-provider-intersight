// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ForecastModel Forecast:Model
//
// Model encapsulated model type and the model generated based on the type for computing forecast. For example if linear regression predictive modeling is used then the model data contains slope, coefficient and RMSE.
//
// swagger:model forecastModel
type ForecastModel struct {
	MoBaseComplexType

	ForecastModelAO1P1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ForecastModel) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseComplexType
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseComplexType = aO0

	// AO1
	var aO1 ForecastModelAO1P1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.ForecastModelAO1P1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ForecastModel) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseComplexType)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	aO1, err := swag.WriteJSON(m.ForecastModelAO1P1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this forecast model
func (m *ForecastModel) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseComplexType
	if err := m.MoBaseComplexType.Validate(formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with ForecastModelAO1P1
	if err := m.ForecastModelAO1P1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ForecastModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastModel) UnmarshalBinary(b []byte) error {
	var res ForecastModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ForecastModelAO1P1 forecast model a o1 p1
//
// swagger:model ForecastModelAO1P1
type ForecastModelAO1P1 struct {

	// The standard error of the estimate is a measure of the accuracy of predictions from predective modeling.
	Accuracy float32 `json:"Accuracy,omitempty"`

	// The collection of model data returned by running a predictive modeling. Data can range from slope, coefficient and more depending on the type of model used.
	ModelData []float64 `json:"ModelData"`

	// Model type indicating type of predictive model used for computing forecast.
	// Enum: [Linear]
	ModelType *string `json:"ModelType,omitempty"`

	// forecast model a o1 p1
	ForecastModelAO1P1 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *ForecastModelAO1P1) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The standard error of the estimate is a measure of the accuracy of predictions from predective modeling.
		Accuracy float32 `json:"Accuracy,omitempty"`

		// The collection of model data returned by running a predictive modeling. Data can range from slope, coefficient and more depending on the type of model used.
		ModelData []float64 `json:"ModelData"`

		// Model type indicating type of predictive model used for computing forecast.
		// Enum: [Linear]
		ModelType *string `json:"ModelType,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv ForecastModelAO1P1

	rcv.Accuracy = stage1.Accuracy
	rcv.ModelData = stage1.ModelData
	rcv.ModelType = stage1.ModelType
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "Accuracy")
	delete(stage2, "ModelData")
	delete(stage2, "ModelType")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.ForecastModelAO1P1 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m ForecastModelAO1P1) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The standard error of the estimate is a measure of the accuracy of predictions from predective modeling.
		Accuracy float32 `json:"Accuracy,omitempty"`

		// The collection of model data returned by running a predictive modeling. Data can range from slope, coefficient and more depending on the type of model used.
		ModelData []float64 `json:"ModelData"`

		// Model type indicating type of predictive model used for computing forecast.
		// Enum: [Linear]
		ModelType *string `json:"ModelType,omitempty"`
	}

	stage1.Accuracy = m.Accuracy
	stage1.ModelData = m.ModelData
	stage1.ModelType = m.ModelType

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.ForecastModelAO1P1) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.ForecastModelAO1P1)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this forecast model a o1 p1
func (m *ForecastModelAO1P1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateModelType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var forecastModelAO1P1TypeModelTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Linear"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		forecastModelAO1P1TypeModelTypePropEnum = append(forecastModelAO1P1TypeModelTypePropEnum, v)
	}
}

const (

	// ForecastModelAO1P1ModelTypeLinear captures enum value "Linear"
	ForecastModelAO1P1ModelTypeLinear string = "Linear"
)

// prop value enum
func (m *ForecastModelAO1P1) validateModelTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, forecastModelAO1P1TypeModelTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ForecastModelAO1P1) validateModelType(formats strfmt.Registry) error {

	if swag.IsZero(m.ModelType) { // not required
		return nil
	}

	// value enum
	if err := m.validateModelTypeEnum("ModelType", "body", *m.ModelType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ForecastModelAO1P1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ForecastModelAO1P1) UnmarshalBinary(b []byte) error {
	var res ForecastModelAO1P1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
