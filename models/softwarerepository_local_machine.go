// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// SoftwarerepositoryLocalMachine Local Machine
//
// The user's local machine is being used as the source of an image.
//
// swagger:model softwarerepositoryLocalMachine
type SoftwarerepositoryLocalMachine struct {
	SoftwarerepositoryFileServer

	// When import action in file MO is updated with 'GeneratePreSignedDownloadUrl', Intersight shall return a presigned URL in this property as part of the PATCH response. The user is expected to subsequently download the file using this URL.
	//
	// Read Only: true
	DownloadURL string `json:"DownloadUrl,omitempty"`

	// Chunk size (in bytes) of the each part of file to be uploaded.
	//
	PartSize int64 `json:"PartSize,omitempty"`

	// When the import action in file MO is updated with 'GeneratePreSignedUploadUrl', Intersight shall return a upload Id in this property as part of the PATCH response.
	//
	UploadID string `json:"UploadId,omitempty"`

	// When a file MO is created with 'LocalMachine' as the source, Intersight shall return a presigned URL in this property as part of the POST response. The user is expected to subsequently upload the file content using this URL. Once this upload has been completed, the user is expected to PATCH the Uploader object's transfer state to success.
	//
	// Read Only: true
	UploadURL string `json:"UploadUrl,omitempty"`

	// When an file MO is created with 'LocalMachine' as the source, Intersight shall return a list of presigned URLs in this property as part of the POST response. The user is expected to subsequently upload the file content in parts using these URLs. Once these uploads have been completed, the user is expected to PATCH the Uploader object's transfer state to success.
	//
	// Read Only: true
	UploadUrls []string `json:"UploadUrls"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *SoftwarerepositoryLocalMachine) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SoftwarerepositoryFileServer
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.SoftwarerepositoryFileServer = aO0

	// AO1
	var dataAO1 struct {
		DownloadURL string `json:"DownloadUrl,omitempty"`

		PartSize int64 `json:"PartSize,omitempty"`

		UploadID string `json:"UploadId,omitempty"`

		UploadURL string `json:"UploadUrl,omitempty"`

		UploadUrls []string `json:"UploadUrls"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.DownloadURL = dataAO1.DownloadURL

	m.PartSize = dataAO1.PartSize

	m.UploadID = dataAO1.UploadID

	m.UploadURL = dataAO1.UploadURL

	m.UploadUrls = dataAO1.UploadUrls

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m SoftwarerepositoryLocalMachine) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.SoftwarerepositoryFileServer)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		DownloadURL string `json:"DownloadUrl,omitempty"`

		PartSize int64 `json:"PartSize,omitempty"`

		UploadID string `json:"UploadId,omitempty"`

		UploadURL string `json:"UploadUrl,omitempty"`

		UploadUrls []string `json:"UploadUrls"`
	}

	dataAO1.DownloadURL = m.DownloadURL

	dataAO1.PartSize = m.PartSize

	dataAO1.UploadID = m.UploadID

	dataAO1.UploadURL = m.UploadURL

	dataAO1.UploadUrls = m.UploadUrls

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this softwarerepository local machine
func (m *SoftwarerepositoryLocalMachine) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SoftwarerepositoryFileServer
	if err := m.SoftwarerepositoryFileServer.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *SoftwarerepositoryLocalMachine) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwarerepositoryLocalMachine) UnmarshalBinary(b []byte) error {
	var res SoftwarerepositoryLocalMachine
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
