// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TamAction Tam:Action
//
// An action is used to react when an object satifies the condition specified in alert query. For e.g. an action in case of an object matching a fieldNotice query would be to create an alert instance of type 'fieldNotice' for the affected object.
//
// swagger:model tamAction
type TamAction struct {
	MoBaseComplexType

	TamActionAO1P1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *TamAction) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseComplexType
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseComplexType = aO0

	// AO1
	var aO1 TamActionAO1P1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.TamActionAO1P1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m TamAction) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseComplexType)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	aO1, err := swag.WriteJSON(m.TamActionAO1P1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this tam action
func (m *TamAction) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseComplexType
	if err := m.MoBaseComplexType.Validate(formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with TamActionAO1P1
	if err := m.TamActionAO1P1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *TamAction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TamAction) UnmarshalBinary(b []byte) error {
	var res TamAction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TamActionAO1P1 tam action a o1 p1
//
// swagger:model TamActionAO1P1
type TamActionAO1P1 struct {

	// Type of the managed object that should be marked with an instance of the Alert (when operation type is create) or that should have an alert instance removed (when operation type is remove).
	AffectedObjectType string `json:"AffectedObjectType,omitempty"`

	// Alert type is used to denote the category of an Intersight alert (FieldNotice, equipment Fault etc.).
	// Enum: [psirt fieldNotice]
	AlertType *string `json:"AlertType,omitempty"`

	// Identifiers represents the filter criteria (property names and values) used to identify an Intersight managed object of type specified in affectedObjectType property. An instance of an alert is then create on (or removed from) the identified managed object.
	Identifiers []*TamIdentifiers `json:"Identifiers"`

	// Uniquely identifies a given action among the set of actions corresponding to an advisory. Primarily used to store and compare results of subsequent iterations corresponding to the action queries.
	Name string `json:"Name,omitempty"`

	// Operation type for the alert action. An action is used to carry out the process of "reacting" to an alert condition. For e.g.in case of a fieldNotice alert, the intention may be to create a new alert (if the condition matches and there is no existing alert) or to remove an existing alert when the alert condition has been remedied.
	// Enum: [create remove]
	OperationType *string `json:"OperationType,omitempty"`

	// Set of SparkSQL queries used determine if a given alert is applicable or not. Refer to https://spark.apache.org/sql/ for more details.
	Queries []*TamQueryEntry `json:"Queries"`

	// Type of Intersight alert. An alert in Intersight could be one of several kinds (FieldNotice, PSIRT etc.). Primarily used for filtering alerts based on the type.
	// Enum: [restApi]
	Type *string `json:"Type,omitempty"`

	// tam action a o1 p1
	TamActionAO1P1 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *TamActionAO1P1) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// Type of the managed object that should be marked with an instance of the Alert (when operation type is create) or that should have an alert instance removed (when operation type is remove).
		AffectedObjectType string `json:"AffectedObjectType,omitempty"`

		// Alert type is used to denote the category of an Intersight alert (FieldNotice, equipment Fault etc.).
		// Enum: [psirt fieldNotice]
		AlertType *string `json:"AlertType,omitempty"`

		// Identifiers represents the filter criteria (property names and values) used to identify an Intersight managed object of type specified in affectedObjectType property. An instance of an alert is then create on (or removed from) the identified managed object.
		Identifiers []*TamIdentifiers `json:"Identifiers"`

		// Uniquely identifies a given action among the set of actions corresponding to an advisory. Primarily used to store and compare results of subsequent iterations corresponding to the action queries.
		Name string `json:"Name,omitempty"`

		// Operation type for the alert action. An action is used to carry out the process of "reacting" to an alert condition. For e.g.in case of a fieldNotice alert, the intention may be to create a new alert (if the condition matches and there is no existing alert) or to remove an existing alert when the alert condition has been remedied.
		// Enum: [create remove]
		OperationType *string `json:"OperationType,omitempty"`

		// Set of SparkSQL queries used determine if a given alert is applicable or not. Refer to https://spark.apache.org/sql/ for more details.
		Queries []*TamQueryEntry `json:"Queries"`

		// Type of Intersight alert. An alert in Intersight could be one of several kinds (FieldNotice, PSIRT etc.). Primarily used for filtering alerts based on the type.
		// Enum: [restApi]
		Type *string `json:"Type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv TamActionAO1P1

	rcv.AffectedObjectType = stage1.AffectedObjectType
	rcv.AlertType = stage1.AlertType
	rcv.Identifiers = stage1.Identifiers
	rcv.Name = stage1.Name
	rcv.OperationType = stage1.OperationType
	rcv.Queries = stage1.Queries
	rcv.Type = stage1.Type
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "AffectedObjectType")
	delete(stage2, "AlertType")
	delete(stage2, "Identifiers")
	delete(stage2, "Name")
	delete(stage2, "OperationType")
	delete(stage2, "Queries")
	delete(stage2, "Type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.TamActionAO1P1 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m TamActionAO1P1) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// Type of the managed object that should be marked with an instance of the Alert (when operation type is create) or that should have an alert instance removed (when operation type is remove).
		AffectedObjectType string `json:"AffectedObjectType,omitempty"`

		// Alert type is used to denote the category of an Intersight alert (FieldNotice, equipment Fault etc.).
		// Enum: [psirt fieldNotice]
		AlertType *string `json:"AlertType,omitempty"`

		// Identifiers represents the filter criteria (property names and values) used to identify an Intersight managed object of type specified in affectedObjectType property. An instance of an alert is then create on (or removed from) the identified managed object.
		Identifiers []*TamIdentifiers `json:"Identifiers"`

		// Uniquely identifies a given action among the set of actions corresponding to an advisory. Primarily used to store and compare results of subsequent iterations corresponding to the action queries.
		Name string `json:"Name,omitempty"`

		// Operation type for the alert action. An action is used to carry out the process of "reacting" to an alert condition. For e.g.in case of a fieldNotice alert, the intention may be to create a new alert (if the condition matches and there is no existing alert) or to remove an existing alert when the alert condition has been remedied.
		// Enum: [create remove]
		OperationType *string `json:"OperationType,omitempty"`

		// Set of SparkSQL queries used determine if a given alert is applicable or not. Refer to https://spark.apache.org/sql/ for more details.
		Queries []*TamQueryEntry `json:"Queries"`

		// Type of Intersight alert. An alert in Intersight could be one of several kinds (FieldNotice, PSIRT etc.). Primarily used for filtering alerts based on the type.
		// Enum: [restApi]
		Type *string `json:"Type,omitempty"`
	}

	stage1.AffectedObjectType = m.AffectedObjectType
	stage1.AlertType = m.AlertType
	stage1.Identifiers = m.Identifiers
	stage1.Name = m.Name
	stage1.OperationType = m.OperationType
	stage1.Queries = m.Queries
	stage1.Type = m.Type

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.TamActionAO1P1) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.TamActionAO1P1)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this tam action a o1 p1
func (m *TamActionAO1P1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentifiers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var tamActionAO1P1TypeAlertTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["psirt","fieldNotice"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tamActionAO1P1TypeAlertTypePropEnum = append(tamActionAO1P1TypeAlertTypePropEnum, v)
	}
}

const (

	// TamActionAO1P1AlertTypePsirt captures enum value "psirt"
	TamActionAO1P1AlertTypePsirt string = "psirt"

	// TamActionAO1P1AlertTypeFieldNotice captures enum value "fieldNotice"
	TamActionAO1P1AlertTypeFieldNotice string = "fieldNotice"
)

// prop value enum
func (m *TamActionAO1P1) validateAlertTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, tamActionAO1P1TypeAlertTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TamActionAO1P1) validateAlertType(formats strfmt.Registry) error {

	if swag.IsZero(m.AlertType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertTypeEnum("AlertType", "body", *m.AlertType); err != nil {
		return err
	}

	return nil
}

func (m *TamActionAO1P1) validateIdentifiers(formats strfmt.Registry) error {

	if swag.IsZero(m.Identifiers) { // not required
		return nil
	}

	for i := 0; i < len(m.Identifiers); i++ {
		if swag.IsZero(m.Identifiers[i]) { // not required
			continue
		}

		if m.Identifiers[i] != nil {
			if err := m.Identifiers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Identifiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var tamActionAO1P1TypeOperationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create","remove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tamActionAO1P1TypeOperationTypePropEnum = append(tamActionAO1P1TypeOperationTypePropEnum, v)
	}
}

const (

	// TamActionAO1P1OperationTypeCreate captures enum value "create"
	TamActionAO1P1OperationTypeCreate string = "create"

	// TamActionAO1P1OperationTypeRemove captures enum value "remove"
	TamActionAO1P1OperationTypeRemove string = "remove"
)

// prop value enum
func (m *TamActionAO1P1) validateOperationTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, tamActionAO1P1TypeOperationTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TamActionAO1P1) validateOperationType(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationTypeEnum("OperationType", "body", *m.OperationType); err != nil {
		return err
	}

	return nil
}

func (m *TamActionAO1P1) validateQueries(formats strfmt.Registry) error {

	if swag.IsZero(m.Queries) { // not required
		return nil
	}

	for i := 0; i < len(m.Queries); i++ {
		if swag.IsZero(m.Queries[i]) { // not required
			continue
		}

		if m.Queries[i] != nil {
			if err := m.Queries[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Queries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var tamActionAO1P1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["restApi"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tamActionAO1P1TypeTypePropEnum = append(tamActionAO1P1TypeTypePropEnum, v)
	}
}

const (

	// TamActionAO1P1TypeRestAPI captures enum value "restApi"
	TamActionAO1P1TypeRestAPI string = "restApi"
)

// prop value enum
func (m *TamActionAO1P1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, tamActionAO1P1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TamActionAO1P1) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("Type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TamActionAO1P1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TamActionAO1P1) UnmarshalBinary(b []byte) error {
	var res TamActionAO1P1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
