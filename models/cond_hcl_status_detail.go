// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CondHclStatusDetail Cond:Hcl Status Detail
//
// The HCL status detail for each component firmware and driver.
//
// swagger:model condHclStatusDetail
type CondHclStatusDetail struct {
	MoBaseMo

	// The related component associated to this status detail HclStatusDetail (adapter or storage controller).
	// Read Only: true
	Component *InventoryBaseRef `json:"Component,omitempty"`

	// The model is considered as part of the hardware profile for the component. This will provide the HCL validation status for the hardware profile. The reasons can be one of the following "Incompatible-Server-With-Component" - the server model and component combination is not listed in HCL "Incompatible-Firmware" - The server's firmware is not listed for this component's hardware profile "Incompatible-Component" - the component's model is not listed in the HCL "Service-Unavailable" - HCL data service is unavailable at the moment (try again later). This could be due to HCL data updating "Not-Evaluated" - the hardware profile was not evaulated for the component because the server's hw/sw status is not listed or server is exempted. "Compatible" - this component's hardware profile is listed in the HCL.
	// Enum: [Missing-Os-Driver-Info Incompatible-Server-With-Component Incompatible-Processor Incompatible-Os-Info Incompatible-Component-Model Incompatible-Firmware Incompatible-Driver Incompatible-Firmware-Driver Service-Unavailable Service-Error Unrecognized-Protocol Not-Evaluated Compatible]
	HardwareStatus *string `json:"HardwareStatus,omitempty"`

	// The current CIMC version for the server normalized for querying HCL data.
	HclCimcVersion string `json:"HclCimcVersion,omitempty"`

	// The current driver name of the component we are validating normalized for querying HCL data.
	HclDriverName string `json:"HclDriverName,omitempty"`

	// The current driver version of the component we are validating normalized for querying HCL data.
	HclDriverVersion string `json:"HclDriverVersion,omitempty"`

	// The current firmware version of the component model normalized for querying HCL data.
	HclFirmwareVersion string `json:"HclFirmwareVersion,omitempty"`

	// The component model we are trying to validate normalized for querying HCL data.
	HclModel string `json:"HclModel,omitempty"`

	// A collection of references to the [cond.HclStatus](mo://cond.HclStatus) Managed Object.
	// When this managed object is deleted, the referenced [cond.HclStatus](mo://cond.HclStatus) MO unsets its reference to this deleted MO.
	// Read Only: true
	HclStatus *CondHclStatusRef `json:"HclStatus,omitempty"`

	// The current CIMC version for the server as received from inventory.
	InvCimcVersion string `json:"InvCimcVersion,omitempty"`

	// The current driver name of the component we are validating as received from inventory.
	InvDriverName string `json:"InvDriverName,omitempty"`

	// The current driver version of the component we are validating as received from inventory.
	InvDriverVersion string `json:"InvDriverVersion,omitempty"`

	// The current firmware version of the component model as received from inventory.
	InvFirmwareVersion string `json:"InvFirmwareVersion,omitempty"`

	// The component model we are trying to validate as received from inventory.
	InvModel string `json:"InvModel,omitempty"`

	// The reason for the status. The reason can be one of "Incompatible-Server-With-Component" - HCL validation has failed because the server model is not validated with this component "Incompatible-Processor" - HCL validation has failed because the processor is not validated with this server "Incompatible-Os-Info" - HCL validation has failed because the os vendor and version is not validated with this server "Incompatible-Component-Model" - HCL validation has failed because the component model is not validated "Incompatible-Firmware" - HCL validation has failed because the component or server firmware version is not validated "Incompatible-Driver" - HCL validation has failed because the driver version is not validated "Incompatible-Firmware-Driver" - HCL validation has failed because the firmware version and driver version is not validated "Missing-Os-Driver-Info" - HCL validation was not performed because we are missing os driver information form the inventory "Service-Unavailable" - HCL data service is unavailable at the moment (try again later). This could be due to HCL data updating "Service-Error" - HCL data service is available but an error occured when making the request or parsing the response "Unrecognized-Protocol" - This service does not recognize the reason code in the response from the HCL data service "Compatible" - this component's inventory data has "Validated" status with the HCL. "Not-Evaluated" - The component is not evaluated against the HCL because the server is exempted.
	// Enum: [Missing-Os-Driver-Info Incompatible-Server-With-Component Incompatible-Processor Incompatible-Os-Info Incompatible-Component-Model Incompatible-Firmware Incompatible-Driver Incompatible-Firmware-Driver Service-Unavailable Service-Error Unrecognized-Protocol Not-Evaluated Compatible]
	Reason *string `json:"Reason,omitempty"`

	// The firmware, driver name and driver version are considered as part of the software profile for the component. This will provide the HCL validation status for the software profile. The reasons can be one of the following "Incompatible-Firmware" - the component's firmware is not listed under the server's hardware and software profile and the component's hardware profile "Incompatible-Driver" - the component's driver is not listed under the server's hardware and software profile and the component's hardware profile "Incompatible-Firmware-Driver" - the component's firmware and driver are not listed under the server's hardware and software profile and the component's hardware profile "Service-Unavailable" - HCL data service is unavailable at the moment (try again later). This could be due to HCL data updating "Not-Evaluated" - the component's hardware status was not evaluated because the server's hardware or software profile is not listed or server is exempted. "Compatible" - this component's hardware profile is listed in the HCL.
	// Enum: [Missing-Os-Driver-Info Incompatible-Server-With-Component Incompatible-Processor Incompatible-Os-Info Incompatible-Component-Model Incompatible-Firmware Incompatible-Driver Incompatible-Firmware-Driver Service-Unavailable Service-Error Unrecognized-Protocol Not-Evaluated Compatible]
	SoftwareStatus *string `json:"SoftwareStatus,omitempty"`

	// The status for the component model, firmware version, driver name, and driver version after validating against the HCL. The status can be one of the following "Unknown" - we do not have enough information to evaluate against the HCL data "Validated" - we have validated this component against the HCL and it has "Validated" status "Not-Validated" - we have validated this component against the HCL and it has "Not-Validated" status. "Not-Evaluated" - The component is not evaluated against the HCL because the server is exempted.
	// Enum: [Incomplete Not-Found Not-Listed Validated Not-Evaluated]
	Status *string `json:"Status,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *CondHclStatusDetail) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Component *InventoryBaseRef `json:"Component,omitempty"`

		HardwareStatus *string `json:"HardwareStatus,omitempty"`

		HclCimcVersion string `json:"HclCimcVersion,omitempty"`

		HclDriverName string `json:"HclDriverName,omitempty"`

		HclDriverVersion string `json:"HclDriverVersion,omitempty"`

		HclFirmwareVersion string `json:"HclFirmwareVersion,omitempty"`

		HclModel string `json:"HclModel,omitempty"`

		HclStatus *CondHclStatusRef `json:"HclStatus,omitempty"`

		InvCimcVersion string `json:"InvCimcVersion,omitempty"`

		InvDriverName string `json:"InvDriverName,omitempty"`

		InvDriverVersion string `json:"InvDriverVersion,omitempty"`

		InvFirmwareVersion string `json:"InvFirmwareVersion,omitempty"`

		InvModel string `json:"InvModel,omitempty"`

		Reason *string `json:"Reason,omitempty"`

		SoftwareStatus *string `json:"SoftwareStatus,omitempty"`

		Status *string `json:"Status,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Component = dataAO1.Component

	m.HardwareStatus = dataAO1.HardwareStatus

	m.HclCimcVersion = dataAO1.HclCimcVersion

	m.HclDriverName = dataAO1.HclDriverName

	m.HclDriverVersion = dataAO1.HclDriverVersion

	m.HclFirmwareVersion = dataAO1.HclFirmwareVersion

	m.HclModel = dataAO1.HclModel

	m.HclStatus = dataAO1.HclStatus

	m.InvCimcVersion = dataAO1.InvCimcVersion

	m.InvDriverName = dataAO1.InvDriverName

	m.InvDriverVersion = dataAO1.InvDriverVersion

	m.InvFirmwareVersion = dataAO1.InvFirmwareVersion

	m.InvModel = dataAO1.InvModel

	m.Reason = dataAO1.Reason

	m.SoftwareStatus = dataAO1.SoftwareStatus

	m.Status = dataAO1.Status

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m CondHclStatusDetail) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		Component *InventoryBaseRef `json:"Component,omitempty"`

		HardwareStatus *string `json:"HardwareStatus,omitempty"`

		HclCimcVersion string `json:"HclCimcVersion,omitempty"`

		HclDriverName string `json:"HclDriverName,omitempty"`

		HclDriverVersion string `json:"HclDriverVersion,omitempty"`

		HclFirmwareVersion string `json:"HclFirmwareVersion,omitempty"`

		HclModel string `json:"HclModel,omitempty"`

		HclStatus *CondHclStatusRef `json:"HclStatus,omitempty"`

		InvCimcVersion string `json:"InvCimcVersion,omitempty"`

		InvDriverName string `json:"InvDriverName,omitempty"`

		InvDriverVersion string `json:"InvDriverVersion,omitempty"`

		InvFirmwareVersion string `json:"InvFirmwareVersion,omitempty"`

		InvModel string `json:"InvModel,omitempty"`

		Reason *string `json:"Reason,omitempty"`

		SoftwareStatus *string `json:"SoftwareStatus,omitempty"`

		Status *string `json:"Status,omitempty"`
	}

	dataAO1.Component = m.Component

	dataAO1.HardwareStatus = m.HardwareStatus

	dataAO1.HclCimcVersion = m.HclCimcVersion

	dataAO1.HclDriverName = m.HclDriverName

	dataAO1.HclDriverVersion = m.HclDriverVersion

	dataAO1.HclFirmwareVersion = m.HclFirmwareVersion

	dataAO1.HclModel = m.HclModel

	dataAO1.HclStatus = m.HclStatus

	dataAO1.InvCimcVersion = m.InvCimcVersion

	dataAO1.InvDriverName = m.InvDriverName

	dataAO1.InvDriverVersion = m.InvDriverVersion

	dataAO1.InvFirmwareVersion = m.InvFirmwareVersion

	dataAO1.InvModel = m.InvModel

	dataAO1.Reason = m.Reason

	dataAO1.SoftwareStatus = m.SoftwareStatus

	dataAO1.Status = m.Status

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this cond hcl status detail
func (m *CondHclStatusDetail) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComponent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardwareStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHclStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CondHclStatusDetail) validateComponent(formats strfmt.Registry) error {

	if swag.IsZero(m.Component) { // not required
		return nil
	}

	if m.Component != nil {
		if err := m.Component.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Component")
			}
			return err
		}
	}

	return nil
}

var condHclStatusDetailTypeHardwareStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Missing-Os-Driver-Info","Incompatible-Server-With-Component","Incompatible-Processor","Incompatible-Os-Info","Incompatible-Component-Model","Incompatible-Firmware","Incompatible-Driver","Incompatible-Firmware-Driver","Service-Unavailable","Service-Error","Unrecognized-Protocol","Not-Evaluated","Compatible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		condHclStatusDetailTypeHardwareStatusPropEnum = append(condHclStatusDetailTypeHardwareStatusPropEnum, v)
	}
}

// property enum
func (m *CondHclStatusDetail) validateHardwareStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, condHclStatusDetailTypeHardwareStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CondHclStatusDetail) validateHardwareStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.HardwareStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateHardwareStatusEnum("HardwareStatus", "body", *m.HardwareStatus); err != nil {
		return err
	}

	return nil
}

func (m *CondHclStatusDetail) validateHclStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.HclStatus) { // not required
		return nil
	}

	if m.HclStatus != nil {
		if err := m.HclStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("HclStatus")
			}
			return err
		}
	}

	return nil
}

var condHclStatusDetailTypeReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Missing-Os-Driver-Info","Incompatible-Server-With-Component","Incompatible-Processor","Incompatible-Os-Info","Incompatible-Component-Model","Incompatible-Firmware","Incompatible-Driver","Incompatible-Firmware-Driver","Service-Unavailable","Service-Error","Unrecognized-Protocol","Not-Evaluated","Compatible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		condHclStatusDetailTypeReasonPropEnum = append(condHclStatusDetailTypeReasonPropEnum, v)
	}
}

// property enum
func (m *CondHclStatusDetail) validateReasonEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, condHclStatusDetailTypeReasonPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CondHclStatusDetail) validateReason(formats strfmt.Registry) error {

	if swag.IsZero(m.Reason) { // not required
		return nil
	}

	// value enum
	if err := m.validateReasonEnum("Reason", "body", *m.Reason); err != nil {
		return err
	}

	return nil
}

var condHclStatusDetailTypeSoftwareStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Missing-Os-Driver-Info","Incompatible-Server-With-Component","Incompatible-Processor","Incompatible-Os-Info","Incompatible-Component-Model","Incompatible-Firmware","Incompatible-Driver","Incompatible-Firmware-Driver","Service-Unavailable","Service-Error","Unrecognized-Protocol","Not-Evaluated","Compatible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		condHclStatusDetailTypeSoftwareStatusPropEnum = append(condHclStatusDetailTypeSoftwareStatusPropEnum, v)
	}
}

// property enum
func (m *CondHclStatusDetail) validateSoftwareStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, condHclStatusDetailTypeSoftwareStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CondHclStatusDetail) validateSoftwareStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.SoftwareStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateSoftwareStatusEnum("SoftwareStatus", "body", *m.SoftwareStatus); err != nil {
		return err
	}

	return nil
}

var condHclStatusDetailTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Incomplete","Not-Found","Not-Listed","Validated","Not-Evaluated"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		condHclStatusDetailTypeStatusPropEnum = append(condHclStatusDetailTypeStatusPropEnum, v)
	}
}

// property enum
func (m *CondHclStatusDetail) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, condHclStatusDetailTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CondHclStatusDetail) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("Status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CondHclStatusDetail) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CondHclStatusDetail) UnmarshalBinary(b []byte) error {
	var res CondHclStatusDetail
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
