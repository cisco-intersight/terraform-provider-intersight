// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetManagedDevice Managed Device
//
// Attributes for Managed Device in Intersight and it maintains the relationship to the Intersight Assist Device. Once added, Device Connector for the Managed Device type is started on the Intersight Assist and status related to it is maintained.
//
// swagger:model assetManagedDevice
type AssetManagedDevice struct {
	MoBaseMo

	// ManagedDevice to Account MO relationship.
	//
	Account *IamAccountRef `json:"Account,omitempty"`

	// Credentials to manage Managed Device.
	//
	Credential *CommCredential `json:"Credential,omitempty"`

	// Intersight Assist Appliance Device within the asset Device Registration.
	//
	DeviceConnectorManager *AssetDeviceRegistrationRef `json:"DeviceConnectorManager,omitempty"`

	// Type of the Device such as VMware, Pure Storage supported by Intersight Assist.
	//
	// Enum: [ APIC DCNM UCSFI IMC IMCM4 IMCM5 HX HXTriton UCSD IntersightAppliance PureStorage VMware ServiceEngine]
	DeviceType string `json:"DeviceType,omitempty"`

	// Ignore Certificates with protocol https for connecting to the Managed Device. It is not used for other protocols.
	//
	IgnoreCert *bool `json:"IgnoreCert,omitempty"`

	// Device is Enabled/Disabled.
	//
	IsEnabled *bool `json:"IsEnabled,omitempty"`

	// Management address of the device. It can be IPv4, IPv6 or FQDN.
	//
	ManagementAddress string `json:"ManagementAddress,omitempty"`

	// Port to use for connecting to the Managed Device. Port is optional. If not specified, default port for protocol is used.
	//
	Port int64 `json:"Port,omitempty"`

	// Protocol to use for connecting to the Managed Device.
	//
	// Enum: [https http]
	Protocol *string `json:"Protocol,omitempty"`

	// ManagedDevice once auto claimed within the asset Device Registration.
	//
	// Read Only: true
	RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

	// Status of communication releated to Managed Device.
	//
	// Read Only: true
	Status *AssetManagedDeviceStatus `json:"Status,omitempty"`

	// Worklfow managed object reference associated with managed device. No managed device operations are supported, in case of associated worklfow is in progress.
	//
	// Read Only: true
	WorkflowInfo *WorkflowWorkflowInfoRef `json:"WorkflowInfo,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *AssetManagedDevice) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		Credential *CommCredential `json:"Credential,omitempty"`

		DeviceConnectorManager *AssetDeviceRegistrationRef `json:"DeviceConnectorManager,omitempty"`

		DeviceType string `json:"DeviceType,omitempty"`

		IgnoreCert *bool `json:"IgnoreCert,omitempty"`

		IsEnabled *bool `json:"IsEnabled,omitempty"`

		ManagementAddress string `json:"ManagementAddress,omitempty"`

		Port int64 `json:"Port,omitempty"`

		Protocol *string `json:"Protocol,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		Status *AssetManagedDeviceStatus `json:"Status,omitempty"`

		WorkflowInfo *WorkflowWorkflowInfoRef `json:"WorkflowInfo,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Account = dataAO1.Account

	m.Credential = dataAO1.Credential

	m.DeviceConnectorManager = dataAO1.DeviceConnectorManager

	m.DeviceType = dataAO1.DeviceType

	m.IgnoreCert = dataAO1.IgnoreCert

	m.IsEnabled = dataAO1.IsEnabled

	m.ManagementAddress = dataAO1.ManagementAddress

	m.Port = dataAO1.Port

	m.Protocol = dataAO1.Protocol

	m.RegisteredDevice = dataAO1.RegisteredDevice

	m.Status = dataAO1.Status

	m.WorkflowInfo = dataAO1.WorkflowInfo

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m AssetManagedDevice) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		Account *IamAccountRef `json:"Account,omitempty"`

		Credential *CommCredential `json:"Credential,omitempty"`

		DeviceConnectorManager *AssetDeviceRegistrationRef `json:"DeviceConnectorManager,omitempty"`

		DeviceType string `json:"DeviceType,omitempty"`

		IgnoreCert *bool `json:"IgnoreCert,omitempty"`

		IsEnabled *bool `json:"IsEnabled,omitempty"`

		ManagementAddress string `json:"ManagementAddress,omitempty"`

		Port int64 `json:"Port,omitempty"`

		Protocol *string `json:"Protocol,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		Status *AssetManagedDeviceStatus `json:"Status,omitempty"`

		WorkflowInfo *WorkflowWorkflowInfoRef `json:"WorkflowInfo,omitempty"`
	}

	dataAO1.Account = m.Account

	dataAO1.Credential = m.Credential

	dataAO1.DeviceConnectorManager = m.DeviceConnectorManager

	dataAO1.DeviceType = m.DeviceType

	dataAO1.IgnoreCert = m.IgnoreCert

	dataAO1.IsEnabled = m.IsEnabled

	dataAO1.ManagementAddress = m.ManagementAddress

	dataAO1.Port = m.Port

	dataAO1.Protocol = m.Protocol

	dataAO1.RegisteredDevice = m.RegisteredDevice

	dataAO1.Status = m.Status

	dataAO1.WorkflowInfo = m.WorkflowInfo

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this asset managed device
func (m *AssetManagedDevice) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCredential(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceConnectorManager(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkflowInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AssetManagedDevice) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Account")
			}
			return err
		}
	}

	return nil
}

func (m *AssetManagedDevice) validateCredential(formats strfmt.Registry) error {

	if swag.IsZero(m.Credential) { // not required
		return nil
	}

	if m.Credential != nil {
		if err := m.Credential.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Credential")
			}
			return err
		}
	}

	return nil
}

func (m *AssetManagedDevice) validateDeviceConnectorManager(formats strfmt.Registry) error {

	if swag.IsZero(m.DeviceConnectorManager) { // not required
		return nil
	}

	if m.DeviceConnectorManager != nil {
		if err := m.DeviceConnectorManager.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DeviceConnectorManager")
			}
			return err
		}
	}

	return nil
}

var assetManagedDeviceTypeDeviceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["","APIC","DCNM","UCSFI","IMC","IMCM4","IMCM5","HX","HXTriton","UCSD","IntersightAppliance","PureStorage","VMware","ServiceEngine"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetManagedDeviceTypeDeviceTypePropEnum = append(assetManagedDeviceTypeDeviceTypePropEnum, v)
	}
}

// property enum
func (m *AssetManagedDevice) validateDeviceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetManagedDeviceTypeDeviceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetManagedDevice) validateDeviceType(formats strfmt.Registry) error {

	if swag.IsZero(m.DeviceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeviceTypeEnum("DeviceType", "body", m.DeviceType); err != nil {
		return err
	}

	return nil
}

var assetManagedDeviceTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["https","http"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetManagedDeviceTypeProtocolPropEnum = append(assetManagedDeviceTypeProtocolPropEnum, v)
	}
}

// property enum
func (m *AssetManagedDevice) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetManagedDeviceTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetManagedDevice) validateProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("Protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *AssetManagedDevice) validateRegisteredDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.RegisteredDevice) { // not required
		return nil
	}

	if m.RegisteredDevice != nil {
		if err := m.RegisteredDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RegisteredDevice")
			}
			return err
		}
	}

	return nil
}

func (m *AssetManagedDevice) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Status")
			}
			return err
		}
	}

	return nil
}

func (m *AssetManagedDevice) validateWorkflowInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.WorkflowInfo) { // not required
		return nil
	}

	if m.WorkflowInfo != nil {
		if err := m.WorkflowInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("WorkflowInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetManagedDevice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetManagedDevice) UnmarshalBinary(b []byte) error {
	var res AssetManagedDevice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
