// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetDeviceRegistration Asset:Device Registration
//
// DeviceRegistration represents a device connector enabled endpoint which has registered with Intersight.
//
// swagger:model assetDeviceRegistration
type AssetDeviceRegistration struct {
	AssetDeviceConnection

	// An identifier for the credential used by the device connector to authenticate with the Intersight web socket gateway.
	AccessKeyID string `json:"AccessKeyId,omitempty"`

	// The account to which the device has been claimed.
	// Read Only: true
	Account *IamAccountRef `json:"Account,omitempty"`

	// The user who claimed the device for the account.
	// Read Only: true
	ClaimedByUser *IamUserRef `json:"ClaimedByUser,omitempty"`

	// The name of the user who claimed the device for the account.
	// Read Only: true
	ClaimedByUserName string `json:"ClaimedByUserName,omitempty"`

	// The date and time at which the device was claimed to this account.
	// Read Only: true
	// Format: date-time
	ClaimedTime strfmt.DateTime `json:"ClaimedTime,omitempty"`

	// The set of nodes within the devices cluster.
	// Read Only: true
	ClusterMembers []*AssetClusterMemberRef `json:"ClusterMembers"`

	// The user who claimed the device for the account.
	// Read Only: true
	DeviceClaim *AssetDeviceClaimRef `json:"DeviceClaim,omitempty"`

	// The devices current configuration.
	// Read Only: true
	DeviceConfiguration *AssetDeviceConfigurationRef `json:"DeviceConfiguration,omitempty"`

	// The hostnames of the managed device. There can be multiple hostnames depending on the number of elements managed (i.e. HA clusters).
	// Read Only: true
	DeviceHostname []string `json:"DeviceHostname"`

	// The IP Addresses of the managed device. There can be multiple management IPs depending on the number of elements managed (i.e. HA clusters) and in-band/out-of-band connectivity.
	// Read Only: true
	DeviceIPAddress []string `json:"DeviceIpAddress"`

	// The domain group to which the device has been assigned.
	// Read Only: true
	DomainGroup *IamDomainGroupRef `json:"DomainGroup,omitempty"`

	// Indicates if the platform is an actual device or an emulated device for testing, demos, etc. Permitted values are [Normal, Emulator, ContainerEmulator].
	// Enum: [ Normal Emulator ContainerEmulator]
	ExecutionMode string `json:"ExecutionMode,omitempty"`

	// The parent device of this device, through which this device connector is connected. If present the device will inherit its ownership through this object and any claim operation will be cascaded from it.
	// e.g. A rack server may have a parent as the Fabric Interconnect cluster to which it is attached.
	// Read Only: true
	ParentConnection *AssetDeviceRegistrationRef `json:"ParentConnection,omitempty"`

	// A signature generated by a parent device used to authenticate that a leaf device is connected through the parent.
	ParentSignature *AssetParentConnectionSignature `json:"ParentSignature,omitempty"`

	// The product Id of the managed device.
	// Read Only: true
	Pid []string `json:"Pid"`

	// The platform type on which device connector is executing.
	// Enum: [ APIC DCNM UCSFI UCSFIISM IMC IMCM4 IMCM5 UCSIOM HX HXTriton UCSD IntersightAppliance PureStorageFlashArray VmwareVcenter ServiceEngine IMCBlade]
	PlatformType string `json:"PlatformType,omitempty"`

	// The device connector's public key used by the cloud to authenticate a connection from the device connector. The public key is used to verify that the signature a device connector sends on connect has been signed by the connector's private key stored on the device's filesystem. Must be a PEM encoded RSA public key string.
	// Read Only: true
	PublicAccessKey string `json:"PublicAccessKey,omitempty"`

	// Flag reported by devices to indicate an administrator of the device has disabled management operations of the device connector and only monitoring is permitted.
	// Read Only: true
	ReadOnly *bool `json:"ReadOnly,omitempty"`

	// The devices current security token that can be used by a device administrator to claim the device.
	// Read Only: true
	SecurityToken *AssetSecurityTokenRef `json:"SecurityToken,omitempty"`

	// A list of serial numbers of the individual device elements (e.g. HA primary/secondary or cluster members) which are exposed as a single unit of management by the device connector.
	// Read Only: true
	Serial []string `json:"Serial"`

	// The vendor of the managed device.
	// Read Only: true
	Vendor string `json:"Vendor,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *AssetDeviceRegistration) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 AssetDeviceConnection
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.AssetDeviceConnection = aO0

	// AO1
	var dataAO1 struct {
		AccessKeyID string `json:"AccessKeyId,omitempty"`

		Account *IamAccountRef `json:"Account,omitempty"`

		ClaimedByUser *IamUserRef `json:"ClaimedByUser,omitempty"`

		ClaimedByUserName string `json:"ClaimedByUserName,omitempty"`

		ClaimedTime strfmt.DateTime `json:"ClaimedTime,omitempty"`

		ClusterMembers []*AssetClusterMemberRef `json:"ClusterMembers"`

		DeviceClaim *AssetDeviceClaimRef `json:"DeviceClaim,omitempty"`

		DeviceConfiguration *AssetDeviceConfigurationRef `json:"DeviceConfiguration,omitempty"`

		DeviceHostname []string `json:"DeviceHostname"`

		DeviceIPAddress []string `json:"DeviceIpAddress"`

		DomainGroup *IamDomainGroupRef `json:"DomainGroup,omitempty"`

		ExecutionMode string `json:"ExecutionMode,omitempty"`

		ParentConnection *AssetDeviceRegistrationRef `json:"ParentConnection,omitempty"`

		ParentSignature *AssetParentConnectionSignature `json:"ParentSignature,omitempty"`

		Pid []string `json:"Pid"`

		PlatformType string `json:"PlatformType,omitempty"`

		PublicAccessKey string `json:"PublicAccessKey,omitempty"`

		ReadOnly *bool `json:"ReadOnly,omitempty"`

		SecurityToken *AssetSecurityTokenRef `json:"SecurityToken,omitempty"`

		Serial []string `json:"Serial"`

		Vendor string `json:"Vendor,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AccessKeyID = dataAO1.AccessKeyID

	m.Account = dataAO1.Account

	m.ClaimedByUser = dataAO1.ClaimedByUser

	m.ClaimedByUserName = dataAO1.ClaimedByUserName

	m.ClaimedTime = dataAO1.ClaimedTime

	m.ClusterMembers = dataAO1.ClusterMembers

	m.DeviceClaim = dataAO1.DeviceClaim

	m.DeviceConfiguration = dataAO1.DeviceConfiguration

	m.DeviceHostname = dataAO1.DeviceHostname

	m.DeviceIPAddress = dataAO1.DeviceIPAddress

	m.DomainGroup = dataAO1.DomainGroup

	m.ExecutionMode = dataAO1.ExecutionMode

	m.ParentConnection = dataAO1.ParentConnection

	m.ParentSignature = dataAO1.ParentSignature

	m.Pid = dataAO1.Pid

	m.PlatformType = dataAO1.PlatformType

	m.PublicAccessKey = dataAO1.PublicAccessKey

	m.ReadOnly = dataAO1.ReadOnly

	m.SecurityToken = dataAO1.SecurityToken

	m.Serial = dataAO1.Serial

	m.Vendor = dataAO1.Vendor

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m AssetDeviceRegistration) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.AssetDeviceConnection)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		AccessKeyID string `json:"AccessKeyId,omitempty"`

		Account *IamAccountRef `json:"Account,omitempty"`

		ClaimedByUser *IamUserRef `json:"ClaimedByUser,omitempty"`

		ClaimedByUserName string `json:"ClaimedByUserName,omitempty"`

		ClaimedTime strfmt.DateTime `json:"ClaimedTime,omitempty"`

		ClusterMembers []*AssetClusterMemberRef `json:"ClusterMembers"`

		DeviceClaim *AssetDeviceClaimRef `json:"DeviceClaim,omitempty"`

		DeviceConfiguration *AssetDeviceConfigurationRef `json:"DeviceConfiguration,omitempty"`

		DeviceHostname []string `json:"DeviceHostname"`

		DeviceIPAddress []string `json:"DeviceIpAddress"`

		DomainGroup *IamDomainGroupRef `json:"DomainGroup,omitempty"`

		ExecutionMode string `json:"ExecutionMode,omitempty"`

		ParentConnection *AssetDeviceRegistrationRef `json:"ParentConnection,omitempty"`

		ParentSignature *AssetParentConnectionSignature `json:"ParentSignature,omitempty"`

		Pid []string `json:"Pid"`

		PlatformType string `json:"PlatformType,omitempty"`

		PublicAccessKey string `json:"PublicAccessKey,omitempty"`

		ReadOnly *bool `json:"ReadOnly,omitempty"`

		SecurityToken *AssetSecurityTokenRef `json:"SecurityToken,omitempty"`

		Serial []string `json:"Serial"`

		Vendor string `json:"Vendor,omitempty"`
	}

	dataAO1.AccessKeyID = m.AccessKeyID

	dataAO1.Account = m.Account

	dataAO1.ClaimedByUser = m.ClaimedByUser

	dataAO1.ClaimedByUserName = m.ClaimedByUserName

	dataAO1.ClaimedTime = m.ClaimedTime

	dataAO1.ClusterMembers = m.ClusterMembers

	dataAO1.DeviceClaim = m.DeviceClaim

	dataAO1.DeviceConfiguration = m.DeviceConfiguration

	dataAO1.DeviceHostname = m.DeviceHostname

	dataAO1.DeviceIPAddress = m.DeviceIPAddress

	dataAO1.DomainGroup = m.DomainGroup

	dataAO1.ExecutionMode = m.ExecutionMode

	dataAO1.ParentConnection = m.ParentConnection

	dataAO1.ParentSignature = m.ParentSignature

	dataAO1.Pid = m.Pid

	dataAO1.PlatformType = m.PlatformType

	dataAO1.PublicAccessKey = m.PublicAccessKey

	dataAO1.ReadOnly = m.ReadOnly

	dataAO1.SecurityToken = m.SecurityToken

	dataAO1.Serial = m.Serial

	dataAO1.Vendor = m.Vendor

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this asset device registration
func (m *AssetDeviceRegistration) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with AssetDeviceConnection
	if err := m.AssetDeviceConnection.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClaimedByUser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClaimedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterMembers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceClaim(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomainGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExecutionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentConnection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentSignature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AssetDeviceRegistration) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Account")
			}
			return err
		}
	}

	return nil
}

func (m *AssetDeviceRegistration) validateClaimedByUser(formats strfmt.Registry) error {

	if swag.IsZero(m.ClaimedByUser) { // not required
		return nil
	}

	if m.ClaimedByUser != nil {
		if err := m.ClaimedByUser.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ClaimedByUser")
			}
			return err
		}
	}

	return nil
}

func (m *AssetDeviceRegistration) validateClaimedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.ClaimedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("ClaimedTime", "body", "date-time", m.ClaimedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AssetDeviceRegistration) validateClusterMembers(formats strfmt.Registry) error {

	if swag.IsZero(m.ClusterMembers) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterMembers); i++ {
		if swag.IsZero(m.ClusterMembers[i]) { // not required
			continue
		}

		if m.ClusterMembers[i] != nil {
			if err := m.ClusterMembers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ClusterMembers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AssetDeviceRegistration) validateDeviceClaim(formats strfmt.Registry) error {

	if swag.IsZero(m.DeviceClaim) { // not required
		return nil
	}

	if m.DeviceClaim != nil {
		if err := m.DeviceClaim.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DeviceClaim")
			}
			return err
		}
	}

	return nil
}

func (m *AssetDeviceRegistration) validateDeviceConfiguration(formats strfmt.Registry) error {

	if swag.IsZero(m.DeviceConfiguration) { // not required
		return nil
	}

	if m.DeviceConfiguration != nil {
		if err := m.DeviceConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DeviceConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *AssetDeviceRegistration) validateDomainGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.DomainGroup) { // not required
		return nil
	}

	if m.DomainGroup != nil {
		if err := m.DomainGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DomainGroup")
			}
			return err
		}
	}

	return nil
}

var assetDeviceRegistrationTypeExecutionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["","Normal","Emulator","ContainerEmulator"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetDeviceRegistrationTypeExecutionModePropEnum = append(assetDeviceRegistrationTypeExecutionModePropEnum, v)
	}
}

// property enum
func (m *AssetDeviceRegistration) validateExecutionModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetDeviceRegistrationTypeExecutionModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetDeviceRegistration) validateExecutionMode(formats strfmt.Registry) error {

	if swag.IsZero(m.ExecutionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateExecutionModeEnum("ExecutionMode", "body", m.ExecutionMode); err != nil {
		return err
	}

	return nil
}

func (m *AssetDeviceRegistration) validateParentConnection(formats strfmt.Registry) error {

	if swag.IsZero(m.ParentConnection) { // not required
		return nil
	}

	if m.ParentConnection != nil {
		if err := m.ParentConnection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ParentConnection")
			}
			return err
		}
	}

	return nil
}

func (m *AssetDeviceRegistration) validateParentSignature(formats strfmt.Registry) error {

	if swag.IsZero(m.ParentSignature) { // not required
		return nil
	}

	if m.ParentSignature != nil {
		if err := m.ParentSignature.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ParentSignature")
			}
			return err
		}
	}

	return nil
}

var assetDeviceRegistrationTypePlatformTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["","APIC","DCNM","UCSFI","UCSFIISM","IMC","IMCM4","IMCM5","UCSIOM","HX","HXTriton","UCSD","IntersightAppliance","PureStorageFlashArray","VmwareVcenter","ServiceEngine","IMCBlade"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetDeviceRegistrationTypePlatformTypePropEnum = append(assetDeviceRegistrationTypePlatformTypePropEnum, v)
	}
}

// property enum
func (m *AssetDeviceRegistration) validatePlatformTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetDeviceRegistrationTypePlatformTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetDeviceRegistration) validatePlatformType(formats strfmt.Registry) error {

	if swag.IsZero(m.PlatformType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePlatformTypeEnum("PlatformType", "body", m.PlatformType); err != nil {
		return err
	}

	return nil
}

func (m *AssetDeviceRegistration) validateSecurityToken(formats strfmt.Registry) error {

	if swag.IsZero(m.SecurityToken) { // not required
		return nil
	}

	if m.SecurityToken != nil {
		if err := m.SecurityToken.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("SecurityToken")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetDeviceRegistration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetDeviceRegistration) UnmarshalBinary(b []byte) error {
	var res AssetDeviceRegistration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
