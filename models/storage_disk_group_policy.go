// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StorageDiskGroupPolicy Disk Group
//
// A reusable RAID disk group configuration that can be applied across multiple servers. Also provides options to move JBOD disks in the disk group to Unconfigured Good state before they are used in the disk group.
//
// swagger:model storageDiskGroupPolicy
type StorageDiskGroupPolicy struct {
	PolicyAbstractPolicy

	// A collection of disks used as hot spares for this RAID group.
	DedicatedHotSpares []*StorageLocalDisk `json:"DedicatedHotSpares"`

	// Relationship to the Organization that owns the Managed Object.
	Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

	// The supported RAID level for the disk group.
	// Enum: [Raid0 Raid1 Raid5 Raid6 Raid10 Raid50 Raid60]
	RaidLevel *string `json:"RaidLevel,omitempty"`

	// Non spanned RAID levels like Raid0, Raid1, Raid5 and Raid6 expect a single group of disks whereas spanned RAID levels need multiple groups of disks with each group representing a span group. Non spanned RAID levels expect one span group and spanned RAID levels accept minimum 2 span groups and up to 8.
	SpanGroups []*StorageSpanGroup `json:"SpanGroups"`

	// A collection of references to the [storage.StoragePolicy](mo://storage.StoragePolicy) Managed Object.
	// When this managed object is deleted, the referenced [storage.StoragePolicy](mo://storage.StoragePolicy) MOs unset their reference to this deleted MO.
	StoragePolicies []*StorageStoragePolicyRef `json:"StoragePolicies"`

	// Selected disks in the disk group in JBOD state will be set to Unconfigured Good state before they are used in virtual drive creation.
	UseJbods *bool `json:"UseJbods,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *StorageDiskGroupPolicy) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 PolicyAbstractPolicy
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.PolicyAbstractPolicy = aO0

	// AO1
	var dataAO1 struct {
		DedicatedHotSpares []*StorageLocalDisk `json:"DedicatedHotSpares"`

		Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

		RaidLevel *string `json:"RaidLevel,omitempty"`

		SpanGroups []*StorageSpanGroup `json:"SpanGroups"`

		StoragePolicies []*StorageStoragePolicyRef `json:"StoragePolicies"`

		UseJbods *bool `json:"UseJbods,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.DedicatedHotSpares = dataAO1.DedicatedHotSpares

	m.Organization = dataAO1.Organization

	m.RaidLevel = dataAO1.RaidLevel

	m.SpanGroups = dataAO1.SpanGroups

	m.StoragePolicies = dataAO1.StoragePolicies

	m.UseJbods = dataAO1.UseJbods

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m StorageDiskGroupPolicy) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.PolicyAbstractPolicy)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		DedicatedHotSpares []*StorageLocalDisk `json:"DedicatedHotSpares"`

		Organization *OrganizationOrganizationRef `json:"Organization,omitempty"`

		RaidLevel *string `json:"RaidLevel,omitempty"`

		SpanGroups []*StorageSpanGroup `json:"SpanGroups"`

		StoragePolicies []*StorageStoragePolicyRef `json:"StoragePolicies"`

		UseJbods *bool `json:"UseJbods,omitempty"`
	}

	dataAO1.DedicatedHotSpares = m.DedicatedHotSpares

	dataAO1.Organization = m.Organization

	dataAO1.RaidLevel = m.RaidLevel

	dataAO1.SpanGroups = m.SpanGroups

	dataAO1.StoragePolicies = m.StoragePolicies

	dataAO1.UseJbods = m.UseJbods

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this storage disk group policy
func (m *StorageDiskGroupPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with PolicyAbstractPolicy
	if err := m.PolicyAbstractPolicy.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDedicatedHotSpares(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRaidLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpanGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragePolicies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StorageDiskGroupPolicy) validateDedicatedHotSpares(formats strfmt.Registry) error {

	if swag.IsZero(m.DedicatedHotSpares) { // not required
		return nil
	}

	for i := 0; i < len(m.DedicatedHotSpares); i++ {
		if swag.IsZero(m.DedicatedHotSpares[i]) { // not required
			continue
		}

		if m.DedicatedHotSpares[i] != nil {
			if err := m.DedicatedHotSpares[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("DedicatedHotSpares" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDiskGroupPolicy) validateOrganization(formats strfmt.Registry) error {

	if swag.IsZero(m.Organization) { // not required
		return nil
	}

	if m.Organization != nil {
		if err := m.Organization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Organization")
			}
			return err
		}
	}

	return nil
}

var storageDiskGroupPolicyTypeRaidLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Raid0","Raid1","Raid5","Raid6","Raid10","Raid50","Raid60"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageDiskGroupPolicyTypeRaidLevelPropEnum = append(storageDiskGroupPolicyTypeRaidLevelPropEnum, v)
	}
}

// property enum
func (m *StorageDiskGroupPolicy) validateRaidLevelEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storageDiskGroupPolicyTypeRaidLevelPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StorageDiskGroupPolicy) validateRaidLevel(formats strfmt.Registry) error {

	if swag.IsZero(m.RaidLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateRaidLevelEnum("RaidLevel", "body", *m.RaidLevel); err != nil {
		return err
	}

	return nil
}

func (m *StorageDiskGroupPolicy) validateSpanGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.SpanGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.SpanGroups); i++ {
		if swag.IsZero(m.SpanGroups[i]) { // not required
			continue
		}

		if m.SpanGroups[i] != nil {
			if err := m.SpanGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("SpanGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDiskGroupPolicy) validateStoragePolicies(formats strfmt.Registry) error {

	if swag.IsZero(m.StoragePolicies) { // not required
		return nil
	}

	for i := 0; i < len(m.StoragePolicies); i++ {
		if swag.IsZero(m.StoragePolicies[i]) { // not required
			continue
		}

		if m.StoragePolicies[i] != nil {
			if err := m.StoragePolicies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("StoragePolicies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *StorageDiskGroupPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StorageDiskGroupPolicy) UnmarshalBinary(b []byte) error {
	var res StorageDiskGroupPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
