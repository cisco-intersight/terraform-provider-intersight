// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MetaDefinition Meta:Definition
//
// The meta-data of managed objects and complex types.
//
// swagger:model metaDefinition
type MetaDefinition struct {
	MoBaseMo

	// The list of access privileges that are required to perform CRUD operations on this managed object. If no access privileges are specified, the object is not accessible.
	// Read Only: true
	AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

	// An array of parent metaclasses in the class inheritance hierarchy. The first element in the array is the parent class. The next element is the grand-parent, etc. The last element in the array is the mo.BaseMo class.
	// Read Only: true
	AncestorClasses []string `json:"AncestorClasses"`

	// Boolean flag to specify whether the meta class is a concrete class or not.
	// Read Only: true
	IsConcrete *bool `json:"IsConcrete,omitempty"`

	// Indicates whether the meta class is a complex type or managed object.
	// Read Only: true
	// Enum: [ManagedObject ComplexType]
	MetaType string `json:"MetaType,omitempty"`

	// The fully-qualified class name of the Managed Object or complex type. For example, "compute:Blade" where the Managed Object is "Blade" and the package is 'compute'.
	// Read Only: true
	Name string `json:"Name,omitempty"`

	// The namespace of the meta.
	// Read Only: true
	Namespace string `json:"Namespace,omitempty"`

	// The fully-qualified name of the parent metaclass in the class inheritance hierarchy.
	// Read Only: true
	ParentClass string `json:"ParentClass,omitempty"`

	// Boolean flag to specify whether instances of this class type can be specified in permissions for instance based access control. Permissions can be created for entire Intersight account or to a subset of resources (instance based access control). In the first release, permissions are supported for entire account or for a subset of organizations.
	// Read Only: true
	PermissionSupported *bool `json:"PermissionSupported,omitempty"`

	// Meta definition for the properties in the meta class and from all classes in the inheritance hierarchy.
	// Read Only: true
	Properties []*MetaPropDefinition `json:"Properties"`

	// Boolean flag to specify whether instances of this class type can be assigned to resource groups that are part of an organization for access control. Inventoried physical/logical objects which needs access control should have rbacResource=yes. These objects are not part of any organization by default like device registrations and should be assigned to organizations for access control. Profiles, policies, workflow definitions which are created by specifying organization need not have this flag set.
	// Read Only: true
	RbacResource *bool `json:"RbacResource,omitempty"`

	// Meta definition for the relationship in the meta class.
	// Read Only: true
	Relationships []*MetaRelationshipDefinition `json:"Relationships"`

	// Restful URL path for the meta.
	// Read Only: true
	RestPath string `json:"RestPath,omitempty"`

	// The version of the service that defines the meta-data.
	// Read Only: true
	Version string `json:"Version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *MetaDefinition) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

		AncestorClasses []string `json:"AncestorClasses"`

		IsConcrete *bool `json:"IsConcrete,omitempty"`

		MetaType string `json:"MetaType,omitempty"`

		Name string `json:"Name,omitempty"`

		Namespace string `json:"Namespace,omitempty"`

		ParentClass string `json:"ParentClass,omitempty"`

		PermissionSupported *bool `json:"PermissionSupported,omitempty"`

		Properties []*MetaPropDefinition `json:"Properties"`

		RbacResource *bool `json:"RbacResource,omitempty"`

		Relationships []*MetaRelationshipDefinition `json:"Relationships"`

		RestPath string `json:"RestPath,omitempty"`

		Version string `json:"Version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AccessPrivileges = dataAO1.AccessPrivileges

	m.AncestorClasses = dataAO1.AncestorClasses

	m.IsConcrete = dataAO1.IsConcrete

	m.MetaType = dataAO1.MetaType

	m.Name = dataAO1.Name

	m.Namespace = dataAO1.Namespace

	m.ParentClass = dataAO1.ParentClass

	m.PermissionSupported = dataAO1.PermissionSupported

	m.Properties = dataAO1.Properties

	m.RbacResource = dataAO1.RbacResource

	m.Relationships = dataAO1.Relationships

	m.RestPath = dataAO1.RestPath

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m MetaDefinition) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

		AncestorClasses []string `json:"AncestorClasses"`

		IsConcrete *bool `json:"IsConcrete,omitempty"`

		MetaType string `json:"MetaType,omitempty"`

		Name string `json:"Name,omitempty"`

		Namespace string `json:"Namespace,omitempty"`

		ParentClass string `json:"ParentClass,omitempty"`

		PermissionSupported *bool `json:"PermissionSupported,omitempty"`

		Properties []*MetaPropDefinition `json:"Properties"`

		RbacResource *bool `json:"RbacResource,omitempty"`

		Relationships []*MetaRelationshipDefinition `json:"Relationships"`

		RestPath string `json:"RestPath,omitempty"`

		Version string `json:"Version,omitempty"`
	}

	dataAO1.AccessPrivileges = m.AccessPrivileges

	dataAO1.AncestorClasses = m.AncestorClasses

	dataAO1.IsConcrete = m.IsConcrete

	dataAO1.MetaType = m.MetaType

	dataAO1.Name = m.Name

	dataAO1.Namespace = m.Namespace

	dataAO1.ParentClass = m.ParentClass

	dataAO1.PermissionSupported = m.PermissionSupported

	dataAO1.Properties = m.Properties

	dataAO1.RbacResource = m.RbacResource

	dataAO1.Relationships = m.Relationships

	dataAO1.RestPath = m.RestPath

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this meta definition
func (m *MetaDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessPrivileges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelationships(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetaDefinition) validateAccessPrivileges(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessPrivileges) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessPrivileges); i++ {
		if swag.IsZero(m.AccessPrivileges[i]) { // not required
			continue
		}

		if m.AccessPrivileges[i] != nil {
			if err := m.AccessPrivileges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AccessPrivileges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var metaDefinitionTypeMetaTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ManagedObject","ComplexType"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metaDefinitionTypeMetaTypePropEnum = append(metaDefinitionTypeMetaTypePropEnum, v)
	}
}

// property enum
func (m *MetaDefinition) validateMetaTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, metaDefinitionTypeMetaTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MetaDefinition) validateMetaType(formats strfmt.Registry) error {

	if swag.IsZero(m.MetaType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMetaTypeEnum("MetaType", "body", m.MetaType); err != nil {
		return err
	}

	return nil
}

func (m *MetaDefinition) validateProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.Properties) { // not required
		return nil
	}

	for i := 0; i < len(m.Properties); i++ {
		if swag.IsZero(m.Properties[i]) { // not required
			continue
		}

		if m.Properties[i] != nil {
			if err := m.Properties[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Properties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MetaDefinition) validateRelationships(formats strfmt.Registry) error {

	if swag.IsZero(m.Relationships) { // not required
		return nil
	}

	for i := 0; i < len(m.Relationships); i++ {
		if swag.IsZero(m.Relationships[i]) { // not required
			continue
		}

		if m.Relationships[i] != nil {
			if err := m.Relationships[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Relationships" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetaDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetaDefinition) UnmarshalBinary(b []byte) error {
	var res MetaDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
