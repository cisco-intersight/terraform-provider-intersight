// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MetaDefinition Meta:Definition
//
// The meta-data of managed objects and complex types.
//
// swagger:model metaDefinition
type MetaDefinition struct {
	MoBaseMo

	// The list of access privileges that are required to perform CRUD operations on this managed object. If no access privileges are specified, the object is not accessible.
	//
	// Read Only: true
	AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

	// An array of parent metaclasses in the class inheritance hierarchy. The first element in the array is the parent class. The next element is the grand-parent, etc. The last element in the array is the mo.BaseMo class.
	//
	// Read Only: true
	AncestorClasses []string `json:"AncestorClasses"`

	// Boolean flag to specify whether the meta class is a concrete class or not.
	//
	// Read Only: true
	IsConcrete *bool `json:"IsConcrete,omitempty"`

	// Indicates whether the meta class is a complex type or managed object.
	//
	// Read Only: true
	// Enum: [ManagedObject ComplexType]
	MetaType string `json:"MetaType,omitempty"`

	// The fully-qualified class name of the Managed Object or complex type. For example, "compute:Blade" where the Managed Object is "Blade" and the package is 'compute'.
	//
	// Read Only: true
	Name string `json:"Name,omitempty"`

	// The namespace of the meta.
	//
	// Read Only: true
	Namespace string `json:"Namespace,omitempty"`

	// The fully-qualified name of the parent metaclass in the class inheritance hierarchy.
	//
	// Read Only: true
	ParentClass string `json:"ParentClass,omitempty"`

	// Meta definition for the properties in the meta class and from all classes in the inheritance hierarchy.
	//
	// Read Only: true
	Properties []*MetaPropDefinition `json:"Properties"`

	// Meta definition for the relationship in the meta class.
	//
	// Read Only: true
	Relationships []*MetaRelationshipDefinition `json:"Relationships"`

	// Restful URL path for the meta.
	//
	// Read Only: true
	RestPath string `json:"RestPath,omitempty"`

	// The version of the service that defines the meta-data.
	//
	// Read Only: true
	Version string `json:"Version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *MetaDefinition) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MoBaseMo
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MoBaseMo = aO0

	// AO1
	var dataAO1 struct {
		AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

		AncestorClasses []string `json:"AncestorClasses"`

		IsConcrete *bool `json:"IsConcrete,omitempty"`

		MetaType string `json:"MetaType,omitempty"`

		Name string `json:"Name,omitempty"`

		Namespace string `json:"Namespace,omitempty"`

		ParentClass string `json:"ParentClass,omitempty"`

		Properties []*MetaPropDefinition `json:"Properties"`

		Relationships []*MetaRelationshipDefinition `json:"Relationships"`

		RestPath string `json:"RestPath,omitempty"`

		Version string `json:"Version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AccessPrivileges = dataAO1.AccessPrivileges

	m.AncestorClasses = dataAO1.AncestorClasses

	m.IsConcrete = dataAO1.IsConcrete

	m.MetaType = dataAO1.MetaType

	m.Name = dataAO1.Name

	m.Namespace = dataAO1.Namespace

	m.ParentClass = dataAO1.ParentClass

	m.Properties = dataAO1.Properties

	m.Relationships = dataAO1.Relationships

	m.RestPath = dataAO1.RestPath

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m MetaDefinition) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MoBaseMo)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		AccessPrivileges []*MetaAccessPrivilege `json:"AccessPrivileges"`

		AncestorClasses []string `json:"AncestorClasses"`

		IsConcrete *bool `json:"IsConcrete,omitempty"`

		MetaType string `json:"MetaType,omitempty"`

		Name string `json:"Name,omitempty"`

		Namespace string `json:"Namespace,omitempty"`

		ParentClass string `json:"ParentClass,omitempty"`

		Properties []*MetaPropDefinition `json:"Properties"`

		Relationships []*MetaRelationshipDefinition `json:"Relationships"`

		RestPath string `json:"RestPath,omitempty"`

		Version string `json:"Version,omitempty"`
	}

	dataAO1.AccessPrivileges = m.AccessPrivileges

	dataAO1.AncestorClasses = m.AncestorClasses

	dataAO1.IsConcrete = m.IsConcrete

	dataAO1.MetaType = m.MetaType

	dataAO1.Name = m.Name

	dataAO1.Namespace = m.Namespace

	dataAO1.ParentClass = m.ParentClass

	dataAO1.Properties = m.Properties

	dataAO1.Relationships = m.Relationships

	dataAO1.RestPath = m.RestPath

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this meta definition
func (m *MetaDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MoBaseMo
	if err := m.MoBaseMo.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessPrivileges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelationships(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetaDefinition) validateAccessPrivileges(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessPrivileges) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessPrivileges); i++ {
		if swag.IsZero(m.AccessPrivileges[i]) { // not required
			continue
		}

		if m.AccessPrivileges[i] != nil {
			if err := m.AccessPrivileges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AccessPrivileges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var metaDefinitionTypeMetaTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ManagedObject","ComplexType"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metaDefinitionTypeMetaTypePropEnum = append(metaDefinitionTypeMetaTypePropEnum, v)
	}
}

// property enum
func (m *MetaDefinition) validateMetaTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, metaDefinitionTypeMetaTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MetaDefinition) validateMetaType(formats strfmt.Registry) error {

	if swag.IsZero(m.MetaType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMetaTypeEnum("MetaType", "body", m.MetaType); err != nil {
		return err
	}

	return nil
}

func (m *MetaDefinition) validateProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.Properties) { // not required
		return nil
	}

	for i := 0; i < len(m.Properties); i++ {
		if swag.IsZero(m.Properties[i]) { // not required
			continue
		}

		if m.Properties[i] != nil {
			if err := m.Properties[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Properties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MetaDefinition) validateRelationships(formats strfmt.Registry) error {

	if swag.IsZero(m.Relationships) { // not required
		return nil
	}

	for i := 0; i < len(m.Relationships); i++ {
		if swag.IsZero(m.Relationships[i]) { // not required
			continue
		}

		if m.Relationships[i] != nil {
			if err := m.Relationships[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Relationships" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetaDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetaDefinition) UnmarshalBinary(b []byte) error {
	var res MetaDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
