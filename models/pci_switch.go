// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PciSwitch Pci:Switch
//
// PCI Switch present in a server connected to two GPUs and one PCIe adapter.
//
// swagger:model pciSwitch
type PciSwitch struct {
	EquipmentBase

	// A collection of references to the [compute.Board](mo://compute.Board) Managed Object.
	// When this managed object is deleted, the referenced [compute.Board](mo://compute.Board) MO unsets its reference to this deleted MO.
	// Read Only: true
	ComputeBoard *ComputeBoardRef `json:"ComputeBoard,omitempty"`

	// It shows the device id of the switch.
	// Read Only: true
	DeviceID string `json:"DeviceId,omitempty"`

	// It shows the composite health of the switch.
	// Read Only: true
	Health string `json:"Health,omitempty"`

	// It shows the number of gpus and pci adapters under each switch.
	// Read Only: true
	Links []*PciLinkRef `json:"Links"`

	// It shows the number of gpus and pci adapters connected the switch.
	// Read Only: true
	NumOfAdaptors string `json:"NumOfAdaptors,omitempty"`

	// It shows shows the PCI address of switch.
	// Read Only: true
	PciAddress string `json:"PciAddress,omitempty"`

	// It shows the PCI slot name for switch.
	// Read Only: true
	PciSlot string `json:"PciSlot,omitempty"`

	// It shows the model information for the switch.
	// Read Only: true
	ProductName string `json:"ProductName,omitempty"`

	// It shows the revision for the product.
	// Read Only: true
	ProductRevision string `json:"ProductRevision,omitempty"`

	// The Device to which this Managed Object is associated.
	// Read Only: true
	RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

	// It shows the sub device id of the switch.
	// Read Only: true
	SubDeviceID string `json:"SubDeviceId,omitempty"`

	// It shows the sub vendor id of the switch.
	// Read Only: true
	SubVendorID string `json:"SubVendorId,omitempty"`

	// It shows the current temperature of the switch.
	// Read Only: true
	Temperature string `json:"Temperature,omitempty"`

	// It shows the type inforamtion of switch.
	Type string `json:"Type,omitempty"`

	// It shows the vendor id of the switch.
	// Read Only: true
	VendorID string `json:"VendorId,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *PciSwitch) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 EquipmentBase
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.EquipmentBase = aO0

	// AO1
	var dataAO1 struct {
		ComputeBoard *ComputeBoardRef `json:"ComputeBoard,omitempty"`

		DeviceID string `json:"DeviceId,omitempty"`

		Health string `json:"Health,omitempty"`

		Links []*PciLinkRef `json:"Links"`

		NumOfAdaptors string `json:"NumOfAdaptors,omitempty"`

		PciAddress string `json:"PciAddress,omitempty"`

		PciSlot string `json:"PciSlot,omitempty"`

		ProductName string `json:"ProductName,omitempty"`

		ProductRevision string `json:"ProductRevision,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		SubDeviceID string `json:"SubDeviceId,omitempty"`

		SubVendorID string `json:"SubVendorId,omitempty"`

		Temperature string `json:"Temperature,omitempty"`

		Type string `json:"Type,omitempty"`

		VendorID string `json:"VendorId,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.ComputeBoard = dataAO1.ComputeBoard

	m.DeviceID = dataAO1.DeviceID

	m.Health = dataAO1.Health

	m.Links = dataAO1.Links

	m.NumOfAdaptors = dataAO1.NumOfAdaptors

	m.PciAddress = dataAO1.PciAddress

	m.PciSlot = dataAO1.PciSlot

	m.ProductName = dataAO1.ProductName

	m.ProductRevision = dataAO1.ProductRevision

	m.RegisteredDevice = dataAO1.RegisteredDevice

	m.SubDeviceID = dataAO1.SubDeviceID

	m.SubVendorID = dataAO1.SubVendorID

	m.Temperature = dataAO1.Temperature

	m.Type = dataAO1.Type

	m.VendorID = dataAO1.VendorID

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m PciSwitch) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.EquipmentBase)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		ComputeBoard *ComputeBoardRef `json:"ComputeBoard,omitempty"`

		DeviceID string `json:"DeviceId,omitempty"`

		Health string `json:"Health,omitempty"`

		Links []*PciLinkRef `json:"Links"`

		NumOfAdaptors string `json:"NumOfAdaptors,omitempty"`

		PciAddress string `json:"PciAddress,omitempty"`

		PciSlot string `json:"PciSlot,omitempty"`

		ProductName string `json:"ProductName,omitempty"`

		ProductRevision string `json:"ProductRevision,omitempty"`

		RegisteredDevice *AssetDeviceRegistrationRef `json:"RegisteredDevice,omitempty"`

		SubDeviceID string `json:"SubDeviceId,omitempty"`

		SubVendorID string `json:"SubVendorId,omitempty"`

		Temperature string `json:"Temperature,omitempty"`

		Type string `json:"Type,omitempty"`

		VendorID string `json:"VendorId,omitempty"`
	}

	dataAO1.ComputeBoard = m.ComputeBoard

	dataAO1.DeviceID = m.DeviceID

	dataAO1.Health = m.Health

	dataAO1.Links = m.Links

	dataAO1.NumOfAdaptors = m.NumOfAdaptors

	dataAO1.PciAddress = m.PciAddress

	dataAO1.PciSlot = m.PciSlot

	dataAO1.ProductName = m.ProductName

	dataAO1.ProductRevision = m.ProductRevision

	dataAO1.RegisteredDevice = m.RegisteredDevice

	dataAO1.SubDeviceID = m.SubDeviceID

	dataAO1.SubVendorID = m.SubVendorID

	dataAO1.Temperature = m.Temperature

	dataAO1.Type = m.Type

	dataAO1.VendorID = m.VendorID

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this pci switch
func (m *PciSwitch) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with EquipmentBase
	if err := m.EquipmentBase.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputeBoard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PciSwitch) validateComputeBoard(formats strfmt.Registry) error {

	if swag.IsZero(m.ComputeBoard) { // not required
		return nil
	}

	if m.ComputeBoard != nil {
		if err := m.ComputeBoard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ComputeBoard")
			}
			return err
		}
	}

	return nil
}

func (m *PciSwitch) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	for i := 0; i < len(m.Links); i++ {
		if swag.IsZero(m.Links[i]) { // not required
			continue
		}

		if m.Links[i] != nil {
			if err := m.Links[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PciSwitch) validateRegisteredDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.RegisteredDevice) { // not required
		return nil
	}

	if m.RegisteredDevice != nil {
		if err := m.RegisteredDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RegisteredDevice")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PciSwitch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PciSwitch) UnmarshalBinary(b []byte) error {
	var res PciSwitch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
